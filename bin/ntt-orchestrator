#!/usr/bin/env bash
# Author: PB, Claude, Kimi
# Date: 2025-09-26
# License: (c) HRDAG, 2025, GPL-2 or newer
#
# ------
# ntt/bin/ntt-orchestrator
#
# NTT ingest dispatcher – supports both device and directory modes
# Note: Must be run with sudo/root privileges for device operations
set -euo pipefail
PATH="/home/pball/projects/ntt/bin:$PATH"

# Check if running as root
if [[ $EUID -ne 0 ]]; then
   echo "Error: This script must be run with sudo or as root" >&2
   echo "Usage: sudo $0 <target> [options]" >&2
   exit 1
fi

# ---------- source config ----------
# Source config from actual user's home (not root's ~)
if [[ -n "$SUDO_USER" ]]; then
  USER_HOME=$(eval echo ~$SUDO_USER)
  CONFIG_FILE="$USER_HOME/.config/ntt/ntt.env"
else
  CONFIG_FILE=~/.config/ntt/ntt.env
fi

if [[ -f "$CONFIG_FILE" ]]; then
  source "$CONFIG_FILE"
else
  # Fallback: use original user when running under sudo
  export PGUSER="${SUDO_USER:-$USER}"
fi

# ---------- config ----------
DB_URL="${NTT_DB_URL:-postgres:///copyjob}"
DB_USER="${PGUSER:-${SUDO_USER:-$USER}}"
IMAGE_ROOT="${NTT_IMAGE_ROOT:-/data/fast/img}"
RAW_ROOT="${NTT_RAW_ROOT:-/data/fast/raw}"
DST_ROOT="${NTT_DST_ROOT:-/data/cold/dst}"
LOG_JSON="${NTT_ORCHESTRATOR_LOG:-/var/log/ntt/orchestrator.jsonl}"
DIAGNOSTICS=""  # Global variable for storing device/image diagnostics
mkdir -p "$(dirname "$LOG_JSON")"
chmod 755 "$(dirname "$LOG_JSON")" 2>/dev/null || true

# Wrapper for psql that handles running as root
psql_as_user() {
  if [[ $EUID -eq 0 ]] && [[ -n "$DB_USER" ]] && [[ "$DB_USER" != "root" ]]; then
    sudo -u "$DB_USER" psql "$@"
  else
    psql "$@"
  fi
}

# ---------- logging functions ----------
log() {
  jq -cn --arg ts "$(date -Iseconds)" \
        --arg stage "$1" \
        --argjson extra "$2" \
        '$extra + {ts: $ts, stage: $stage}' \
  >> "$LOG_JSON"
  chmod 644 "$LOG_JSON" 2>/dev/null || true
}

fail() {
  echo "Error: $1" >&2
  log error "{\"msg\": \"$1\"}"
  exit 1
}

# ---------- identification functions ----------
identify_device() {
  local dev="$1"
  local user_message="$2"

  if [[ ! -e "$dev" ]]; then
    fail "Device $dev not found"
  fi

  # Comprehensive device diagnostics BEFORE content hash
  local DIAG_FILE="/tmp/ntt-diag-$$"
  {
    echo "=== DISK HARDWARE INFO ==="
    echo "--- hdparm identity ---"
    sudo hdparm -I "$dev" 2>&1 || echo "hdparm failed"
    echo ""
    echo "--- lsblk overview ---"
    lsblk "$dev" 2>&1 || echo "lsblk failed"
    echo ""
    echo "--- fdisk partition table ---"
    sudo fdisk -l "$dev" 2>&1 || echo "fdisk failed"
    echo ""
    echo "--- parted partition info ---"
    sudo parted "$dev" print 2>&1 || echo "parted failed"
    echo ""

    echo "=== HEALTH & SMART DATA ==="
    # NOTE: For partitions (e.g., /dev/sdc1), USB bridges may block SMART access.
    # Always check parent device (e.g., /dev/sdc) for real disk SMART data.
    # TODO: Auto-detect partition and query parent device for SMART
    sudo smartctl -a "$dev" 2>&1 || echo "smartctl failed or not available"
    echo ""

    echo "=== CONTENT ANALYSIS ==="
    echo "--- file signature ---"
    sudo file -s "$dev" 2>&1 || echo "file failed"
    echo ""
    echo "--- wipefs signatures ---"
    sudo wipefs "$dev" 2>&1 || echo "wipefs failed"
    echo ""
    echo "--- blkid UUIDs ---"
    sudo blkid "$dev"* 2>&1 || echo "blkid failed"
    echo ""
    echo "--- MBR/first sector (512 bytes hex dump) ---"
    sudo dd if="$dev" bs=512 count=1 2>/dev/null | xxd 2>&1 || echo "dd/xxd failed"
  } > "$DIAG_FILE"

  # Store diagnostics for database insertion
  DIAGNOSTICS=$(cat "$DIAG_FILE")
  rm -f "$DIAG_FILE"

  # Content hash from first 1MB + last 1MB (for deduplication)
  # Use dd with conv=noerror to handle damaged media gracefully
  SIG_FILE="/tmp/ntt-sig-$$"

  # Try to read first 1MB (up to 2048 sectors of 512 bytes)
  # conv=noerror,sync continues on read errors and pads with zeros
  dd if="$dev" of="$SIG_FILE" bs=512 count=2048 conv=noerror,sync status=none 2>/dev/null || true

  # Try to read last 1MB (skip to end - 1MB, or start if device < 1MB)
  # Get device size in 512-byte sectors
  local dev_sectors=$(blockdev --getsz "$dev" 2>/dev/null || echo 2048)
  local skip_sectors=$((dev_sectors - 2048))
  if [[ $skip_sectors -lt 0 ]]; then
    skip_sectors=0
  fi
  dd if="$dev" of="$SIG_FILE" bs=512 skip=$skip_sectors count=2048 conv=noerror,sync oflag=append status=none 2>/dev/null || true

  # Generate hash from whatever we could read (may include zero-padded bad sectors)
  local medium_hash=$(b3sum < "$SIG_FILE" | cut -d' ' -f1 | cut -c1-32)
  rm -f "$SIG_FILE"

  # Human name - use different strategy for removable media vs fixed disks
  local removable=$(lsblk -no HOTPLUG "$dev" 2>/dev/null || echo 0)
  local dev_size_mb=$((dev_sectors * 512 / 1024 / 1024))

  if [[ "$removable" == "1" ]] || [[ $dev_size_mb -lt 10 ]]; then
    # Removable media (floppy, USB stick, etc) or very small device
    # Use: floppy_YYYYMMDD_HHMMSS_hashprefix
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local hash_prefix="${medium_hash:0:8}"
    local medium_human="floppy_${timestamp}_${hash_prefix}"
  else
    # Fixed disk - use hardware info
    MODEL=$(lsblk -no MODEL "$dev" | tr -s ' ' '_')
    SERIAL=$(lsblk -no SERIAL "$dev" | tr -s ' ' '_')
    local medium_human="${MODEL:-unknown}_${SERIAL:-unknown}"
  fi

  log identify "{\"medium_hash\":\"$medium_hash\",\"medium_human\":\"$medium_human\",\"message\":\"$user_message\",\"dev\":\"$dev\"}"

  # Return: hash:human:message (diagnostics stored in global DIAGNOSTICS variable)
  echo "$medium_hash:$medium_human:$user_message"
}

identify_path() {
  local path="$1"

  if [[ ! -d "$path" ]]; then
    fail "Path $path not found or not a directory"
  fi

  # Generate hash from path only (consistent across runs)
  local medium_human="$(basename "$path")"
  local medium_hash=$(echo -n "$path" | b3sum | cut -d' ' -f1 | cut -c1-32)

  log identify "{\"medium_human\": \"$medium_human\", \"medium_hash\": \"$medium_hash\", \"path\": \"$path\"}"

  # Return values via echo
  echo "$medium_hash:$medium_human"
}

identify_image() {
  local image_path="$1"
  local user_message="${2:-}"

  if [[ ! -f "$image_path" ]]; then
    fail "Image file not found: $image_path"
  fi

  # Extract human-readable name from filename (without extension)
  local filename=$(basename "$image_path")
  local medium_human="${filename%.*}"

  # Capture image diagnostics BEFORE content hash
  local DIAG_FILE="/tmp/ntt-img-diag-$$"
  {
    echo "=== IMAGE METADATA ==="
    echo "Image path: $image_path"
    echo "Size: $(stat -c %s "$image_path") bytes ($(stat -c %s "$image_path" | numfmt --to=iec-i --suffix=B 2>/dev/null || stat -c %s "$image_path"))"
    echo "Modified: $(stat -c %y "$image_path")"
    echo ""

    echo "=== FILESYSTEM SIGNATURE ==="
    file -s "$image_path" 2>&1 || echo "file command failed"
    echo ""

    echo "=== BLKID OUTPUT ==="
    echo "(Captured after loop device creation in mount_image)"
  } > "$DIAG_FILE"

  # Store diagnostics in temp file for parent process to read
  cp "$DIAG_FILE" "/tmp/ntt-image-diag-$$"
  rm -f "$DIAG_FILE"

  # Generate hash from image content (head + tail, like identify_device)
  SIG_FILE="/tmp/ntt-sig-$$"
  head -c 1M "$image_path" > "$SIG_FILE"
  tail -c 1M "$image_path" >> "$SIG_FILE"
  local medium_hash=$(b3sum < "$SIG_FILE" | cut -d' ' -f1 | cut -c1-32)
  rm -f "$SIG_FILE"

  log identify "{\"medium_human\": \"$medium_human\", \"medium_hash\": \"$medium_hash\", \"message\": \"$user_message\", \"image\": \"$image_path\"}"

  # Return: hash:human:message (diagnostics stored in global DIAGNOSTICS variable)
  echo "$medium_hash:$medium_human:$user_message"
}

# ---------- health check functions ----------
check_device_health() {
  local dev="$1"

  local SMART_FAIL=$(smartctl -H "$dev" 2>/dev/null | grep -c "FAILED" || echo 0)
  local PROPRIETARY=$(smartctl -i "$dev" 2>/dev/null | grep -Ei "G-RAID|hardware-raid" | wc -l || echo 0)
  local REMOVABLE=$(lsblk -no HOTPLUG "$dev" 2>/dev/null || echo 0)

  local IMAGE_FIRST=false
  if [[ $SMART_FAIL -gt 0 ]] || [[ $PROPRIETARY -gt 0 ]] || [[ "$REMOVABLE" == "1" ]]; then
    IMAGE_FIRST=true
  fi

  log health "{\"image_first\": $IMAGE_FIRST, \"smart_fail\": $SMART_FAIL, \"proprietary\": $PROPRIETARY}"

  # Return the value
  echo "$IMAGE_FIRST"
}

# ---------- database functions ----------
check_duplicate() {
  local medium_hash="$1"
  local force="$2"

  # DISABLED: Duplicate check was causing false positives
  # if ! "$force"; then
  #   EXISTS=$(psql_as_user "$DB_URL" -t -A -c "SELECT 1 FROM medium WHERE medium_hash='$medium_hash'" 2>/dev/null || echo "")
  #   if [[ -n $EXISTS ]]; then
  #     log skip "{\"reason\": \"already ingested\"}"
  #     exit 2
  #   fi
  # fi
  return 0
}

insert_medium() {
  local medium_hash="$1"
  local medium_human="$2"
  local health="${3:-false}"
  local message="${4:-}"
  local diagnostics="${5:-}"

  # Use psql parameter binding to safely handle all special characters
  psql_as_user "$DB_URL" \
    -v hash="$medium_hash" \
    -v human="$medium_human" \
    -v health="$health" \
    -v msg="$message" \
    -v diag="$diagnostics" \
<<'SQL'
INSERT INTO medium (medium_hash, medium_human, health, message, diagnostics)
VALUES (:'hash', :'human', :'health', :'msg', :'diag')
ON CONFLICT (medium_hash) DO UPDATE
SET message = EXCLUDED.message,
    diagnostics = EXCLUDED.diagnostics;
SQL
}

# ---------- mount/unmount functions ----------
mount_image() {
  local image_path="$1"
  local medium_hash="$2"

  # Create loop device (read-only)
  local loop_device=$(losetup -f --show -r "$image_path")
  if [[ -z "$loop_device" ]]; then
    fail "Failed to create loop device for $image_path"
  fi

  # Get full blkid output for diagnostics
  local blkid_full=$(blkid "$loop_device" 2>/dev/null || echo "")

  # Extract filesystem type for mounting
  local fs_type=$(blkid -o value -s TYPE "$loop_device" 2>/dev/null || echo "")

  # Write blkid output to temp file for parent to append to diagnostics
  if [[ -n "$blkid_full" ]]; then
    echo "$blkid_full" > "/tmp/ntt-blkid-$$"
  fi

  log mount_image "{\"image\": \"$image_path\", \"loop\": \"$loop_device\", \"medium_hash\": \"$medium_hash\", \"fs_type\": \"$fs_type\"}"

  # Create mount point
  local mnt="/mnt/ntt/${medium_hash}"
  mkdir -p "$mnt"

  # Mount with detected filesystem type (or fallback to auto-detect)
  if [[ -n "$fs_type" ]]; then
    if ! mount -t "$fs_type" -o ro,noatime,nodev,nosuid "$loop_device" "$mnt"; then
      losetup -d "$loop_device"
      rmdir "$mnt" 2>/dev/null || true
      fail "Failed to mount $loop_device at $mnt (fs_type: $fs_type)"
    fi
  else
    if ! mount -o ro,noatime,nodev,nosuid "$loop_device" "$mnt"; then
      losetup -d "$loop_device"
      rmdir "$mnt" 2>/dev/null || true
      fail "Failed to mount $loop_device at $mnt"
    fi
  fi

  log mount_success "{\"mnt\": \"$mnt\", \"loop\": \"$loop_device\", \"fs_type\": \"$fs_type\"}"

  # Return mount path and loop device (separated by :)
  echo "$mnt:$loop_device"
}

unmount_image() {
  local mnt="$1"
  local loop_device="$2"

  log unmount_image "{\"mnt\": \"$mnt\", \"loop\": \"$loop_device\"}"

  # Unmount
  umount "$mnt" 2>/dev/null || true

  # Detach loop device
  [[ -n "$loop_device" ]] && losetup -d "$loop_device" 2>/dev/null || true

  # Remove mount point
  rmdir "$mnt" 2>/dev/null || true

  log unmount_success "{}"
}

# ---------- processing functions ----------
run_enum() {
  local mnt="$1"
  local medium_hash="$2"

  RAW="$RAW_ROOT/${medium_hash}.raw"
  log enum_spawn "{\"mnt\": \"$mnt\", \"raw\": \"$RAW\"}"
  ntt-enum "$mnt" "$medium_hash" "$RAW"

  # Make raw file world readable
  chmod 644 "$RAW" 2>/dev/null || true

  echo "$RAW"
}

run_loader() {
  local medium_hash="$1"
  local raw="$2"

  log loader_spawn "{\"raw\": \"$raw\"}"
  ntt-loader "$raw" "$medium_hash"
}

run_copy_workers() {
  local medium_hash="$1"
  local workers="${2:-8}"

  echo "[$(date -Iseconds)] Copy workers not implemented yet - skipping file copying" >&2
  log copy_spawn "{\"workers\": 0, \"status\": \"not_implemented\", \"msg\": \"ntt-copy-worker not yet implemented\"}"

  # TODO: Implement ntt-copy-worker for actual file copying/deduplication
  # This would copy files from source to destination with hash-based deduplication
}

cleanup_image() {
  local medium_hash="$1"

  COPIED=$(psql_as_user "$DB_URL" -t -A -c \
    "SELECT count(*) FILTER (WHERE copied) = count(*) FROM inode WHERE medium_hash='$medium_hash'" 2>/dev/null || echo 0)
  if [[ $COPIED -eq 1 ]]; then
    rm -f "$IMAGE_ROOT/${medium_hash}.img" "$IMAGE_ROOT/${medium_hash}.map"
    log image_delete "{\"reason\": \"all_inodes_copied\"}"
  fi
}

# ---------- mode handlers ----------
handle_device_mode() {
  local dev="$1"
  local image_first="$2"
  local force="$3"
  local enum_only="$4"
  local user_message="$5"

  # Require --message for device mode
  if [[ -z "$user_message" ]]; then
    fail "Device mode requires --message flag (e.g., --message=\"old maxtor ide 300GB\")"
  fi

  # Identify device with user message
  local identify_result=$(identify_device "$dev" "$user_message")
  local medium_hash="${identify_result%%:*}"
  local temp="${identify_result#*:}"
  local medium_human="${temp%%:*}"
  local message="${temp#*:}"

  check_duplicate "$medium_hash" "$force"

  # Insert medium record NOW (before imaging) so hardware can be disconnected
  # This captures all hardware diagnostics while device is still attached
  local IMG="$IMAGE_ROOT/${medium_hash}.img"
  insert_medium "$medium_hash" "$medium_human" "true" "$message" "$DIAGNOSTICS"
  psql_as_user "$DB_URL" -c "UPDATE medium SET image_path = '$IMG' WHERE medium_hash = '$medium_hash';" 2>/dev/null || true

  log medium_inserted "{\"medium_hash\":\"$medium_hash\",\"medium_human\":\"$medium_human\",\"timing\":\"before_imaging\"}"

  # Image the device using ntt-imager
  local MAP="$IMAGE_ROOT/${medium_hash}.map"
  log imager_spawn "{\"img\":\"$IMG\",\"map\":\"$MAP\",\"message\":\"$message\"}"

  ntt-imager "$dev" "$IMG" "$MAP"
  local exit_code=$?

  if [[ $exit_code -eq 2 ]]; then
    fail "ntt-imager failed with error (exit code 2)"
  elif [[ $exit_code -eq 1 ]]; then
    log imager_partial "{\"medium_hash\":\"$medium_hash\",\"msg\":\"Exhausted all recovery phases, some sectors unreadable\"}"
  else
    log imager_success "{\"medium_hash\":\"$medium_hash\",\"msg\":\"100% rescued\"}"
  fi

  # Mount the image as loop device
  LOOP=$(losetup -f --show -r "$IMG")
  MNT="/mnt/ntt/${medium_hash}"
  mkdir -p "$MNT"
  mount -o ro,nodev,nosuid,noatime "$LOOP" "$MNT"

  # Run enumeration
  RAW=$(run_enum "$MNT" "$medium_hash")

  # Run full pipeline unless --enum-only
  if ! "$enum_only"; then
    run_loader "$medium_hash" "$RAW"
    run_copy_workers "$medium_hash"
  fi

  # Cleanup
  umount "$MNT" || true
  losetup -d "$LOOP" || true
  rmdir "$MNT" 2>/dev/null || true
}

handle_directory_mode() {
  local path="$1"
  local force="$2"
  local enum_only="$3"

  # Identify path
  local identify_result=$(identify_path "$path")
  local medium_hash="${identify_result%%:*}"
  local medium_human="${identify_result#*:}"

  # Check if raw file already exists
  RAW="$RAW_ROOT/${medium_hash}.raw"
  if [[ -f "$RAW" ]] && ! "$force"; then
    fail "Raw file already exists: $RAW (use --force to overwrite)"
  fi

  check_duplicate "$medium_hash" "$force"

  # Insert into database (no health check for paths)
  insert_medium "$medium_hash" "$medium_human" "false"

  # Run enum directly on the path
  RAW=$(run_enum "$path" "$medium_hash")

  # Run full pipeline unless --enum-only
  if ! "$enum_only"; then
    run_loader "$medium_hash" "$RAW"
    run_copy_workers "$medium_hash"
  fi
}

handle_image_mode() {
  local image_path="$1"
  local force="$2"
  local enum_only="$3"
  local user_message="${4:-}"

  # Setup cleanup trap for errors
  local loop_device=""
  local mnt=""
  cleanup_on_error() {
    if [[ -n "$mnt" && -n "$loop_device" ]]; then
      unmount_image "$mnt" "$loop_device"
    fi
  }
  trap cleanup_on_error EXIT SIGINT SIGTERM

  # Identify image (content-based hash) with message
  local identify_result=$(identify_image "$image_path" "$user_message")
  local medium_hash="${identify_result%%:*}"
  local temp="${identify_result#*:}"
  local medium_human="${temp%%:*}"
  local message="${temp#*:}"

  # Read image diagnostics from temp file
  if [[ -f "/tmp/ntt-image-diag-$$" ]]; then
    DIAGNOSTICS=$(cat "/tmp/ntt-image-diag-$$")
    rm -f "/tmp/ntt-image-diag-$$"
  fi

  # Check if raw file already exists
  RAW="$RAW_ROOT/${medium_hash}.raw"
  if [[ -f "$RAW" ]] && ! "$force"; then
    fail "Raw file already exists: $RAW (use --force to overwrite)"
  fi

  check_duplicate "$medium_hash" "$force"

  # Mount image (writes blkid to temp file)
  local mount_result=$(mount_image "$image_path" "$medium_hash")
  mnt="${mount_result%%:*}"
  loop_device="${mount_result#*:}"

  # Append blkid from temp file to diagnostics
  if [[ -f "/tmp/ntt-blkid-$$" ]]; then
    DIAGNOSTICS="${DIAGNOSTICS}
$(cat /tmp/ntt-blkid-$$)"
    rm -f "/tmp/ntt-blkid-$$"
  fi

  # Insert into database with image_path, message, and diagnostics
  insert_medium "$medium_hash" "$medium_human" "ok" "$message" "$DIAGNOSTICS"
  psql_as_user "$DB_URL" -c "UPDATE medium SET image_path = '$image_path' WHERE medium_hash = '$medium_hash';" 2>/dev/null || true

  # Run enum on mounted image
  RAW=$(run_enum "$mnt" "$medium_hash")

  # Run full pipeline unless --enum-only
  if ! "$enum_only"; then
    run_loader "$medium_hash" "$RAW"
    run_copy_workers "$medium_hash"
  fi

  # Cleanup (unmount and detach loop)
  unmount_image "$mnt" "$loop_device"
  trap - EXIT SIGINT SIGTERM  # Clear trap after successful cleanup
}

# ---------- load-only mode handler ----------
handle_load_only_mode() {
  local raw_file="$1"

  # Check if raw file exists
  if [[ ! -f "$raw_file" ]]; then
    fail "Raw file not found: $raw_file"
  fi

  # Extract medium_hash from filename (remove path and .raw extension)
  local filename=$(basename "$raw_file")
  local medium_hash="${filename%.raw}"

  # Validate it looks like a hash
  if [[ ! "$medium_hash" =~ ^[a-f0-9]{16,64}$ ]]; then
    fail "Invalid filename format: expected hash.raw, got $filename"
  fi

  echo "[$(date -Iseconds)] Loading raw file: $raw_file (medium_hash: $medium_hash)" >&2
  log load_only_start "{\"raw_file\": \"$raw_file\", \"medium_hash\": \"$medium_hash\"}"

  # Run loader directly (no enum, no copy workers)
  ntt-loader "$raw_file" "$medium_hash"

  log load_only_done "{\"medium_hash\": \"$medium_hash\", \"exit\": 0}"
}

# ---------- argparse ----------
usage() {
  cat <<EOF
Usage:
  sudo $0 [--enum-only] [--force] /dev/sdX                # Device enumeration (PARTIAL)
  sudo $0 [--enum-only] [--force] /path/to/directory      # Directory enumeration
  sudo $0 [--enum-only] [--force] --image /path/to/image  # Disk image enumeration
  sudo $0 --load-only /path/to/file.raw                   # Load .raw into database

Current implementation status:
  ❌ TODO: Device imaging, mounting, health checks
  ✅ WORKING: Directory enumeration → .raw files → PostgreSQL loading
  ✅ WORKING: Disk image processing (content-based hash, auto mount/unmount)
  ✅ WORKING: .raw file loading into database
  ❌ TODO: Copy workers (file copying/deduplication)

Modes:
  /path/to/dir    Enumerate directory, optionally load to database
  /dev/sdX        Enumerate device (basic - no imaging/mounting yet)
  --image FILE    Process disk image (auto mount/unmount, content-based hash)
  --load-only     Load existing .raw file into PostgreSQL

Options:
  --enum-only     Stop after enumeration (.raw file creation)
  --force         Bypass duplicate checking
  --load-only     Load mode: process existing .raw file
  --image FILE    Image mode: process disk image file

Examples:
  sudo $0 --image /data/fast/img/tm-20140409-partition3.img
  sudo $0 --image /data/fast/img/partition3.img --enum-only
  sudo $0 --force --image /path/to/image.img
EOF
  exit 1
}

# Parse arguments
[[ $# -ge 1 ]] || usage

# Initialize flags
LOAD_ONLY_MODE=false
IMAGE_MODE=false
IMAGE_FIRST=false
FORCE=false
ENUM_ONLY=false
TARGET=""
LOAD_ONLY_FILE=""
IMAGE_FILE=""
USER_MESSAGE=""

# Parse options first
while [[ $# -gt 0 ]]; do
  case $1 in
    --load-only)
      LOAD_ONLY_MODE=true
      shift
      # Next argument should be the .raw file
      if [[ $# -eq 1 ]]; then
        LOAD_ONLY_FILE="$1"
        shift
      else
        usage
      fi
      ;;
    --image)
      IMAGE_MODE=true
      shift
      # Next argument should be the image file
      if [[ $# -ge 1 && "$1" != -* ]]; then
        IMAGE_FILE="$1"
        shift
      else
        echo "Error: --image requires an image file path" >&2
        usage
      fi
      ;;
    --image-first)
      IMAGE_FIRST=true
      shift
      ;;
    --message)
      shift
      if [[ $# -ge 1 && "$1" != -* ]]; then
        USER_MESSAGE="$1"
        shift
      else
        echo "Error: --message requires a description string" >&2
        usage
      fi
      ;;
    --force)
      FORCE=true
      shift
      ;;
    --enum-only)
      ENUM_ONLY=true
      shift
      ;;
    -*)
      echo "Unknown option: $1" >&2
      usage
      ;;
    *)
      # First non-option argument is the target
      if [[ -z "$TARGET" && "$LOAD_ONLY_MODE" == false && "$IMAGE_MODE" == false ]]; then
        TARGET="$1"
        shift
        break  # Stop parsing after target is set
      else
        # Extra arguments not allowed
        usage
      fi
      ;;
  esac
done

# Check for extra arguments after target
if [[ $# -gt 0 ]]; then
  echo "Extra arguments not allowed after target: $@" >&2
  usage
fi

# Validate arguments
if [[ "$LOAD_ONLY_MODE" == true ]]; then
  [[ -n "$LOAD_ONLY_FILE" ]] || usage
elif [[ "$IMAGE_MODE" == true ]]; then
  [[ -n "$IMAGE_FILE" ]] || usage
else
  [[ -n "$TARGET" ]] || usage
fi

# ---------- main ----------
if [[ "$LOAD_ONLY_MODE" == "true" ]]; then
  handle_load_only_mode "$LOAD_ONLY_FILE"
elif [[ "$IMAGE_MODE" == "true" ]]; then
  handle_image_mode "$IMAGE_FILE" "$FORCE" "$ENUM_ONLY" "$USER_MESSAGE"
elif [[ "$TARGET" == /dev/* ]]; then
  handle_device_mode "$TARGET" "$IMAGE_FIRST" "$FORCE" "$ENUM_ONLY" "$USER_MESSAGE"
else
  handle_directory_mode "$TARGET" "$FORCE" "$ENUM_ONLY"
fi

log done "{\"exit\": 0}"
exit 0
