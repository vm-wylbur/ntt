#!/usr/bin/env bash
# Author: PB, Claude, Kimi
# Date: 2025-09-26
# License: (c) HRDAG, 2025, GPL-2 or newer
#
# ------
# ntt/bin/ntt-orchestrator
#
# NTT ingest dispatcher – supports both device and directory modes
# Note: Must be run with sudo/root privileges for device operations
set -euo pipefail
PATH="/home/pball/projects/ntt/bin:$PATH"

# Check if running as root
if [[ $EUID -ne 0 ]]; then
   echo "Error: This script must be run with sudo or as root" >&2
   echo "Usage: sudo $0 <target> [options]" >&2
   exit 1
fi

# ---------- source config ----------
if [[ -f ~/.config/ntt/ntt.env ]]; then
  source ~/.config/ntt/ntt.env
else
  # Fallback: use original user when running under sudo
  export PGUSER="${SUDO_USER:-$USER}"
fi

# ---------- config ----------
DB_URL="${NTT_DB_URL:-postgres:///copyjob}"
IMAGE_ROOT="${NTT_IMAGE_ROOT:-/data/fast/images}"
RAW_ROOT="${NTT_RAW_ROOT:-/data/fast/raw}"
DST_ROOT="${NTT_DST_ROOT:-/data/cold/dst}"
LOG_JSON="${NTT_ORCHESTRATOR_LOG:-/var/log/ntt/orchestrator.jsonl}"
mkdir -p "$(dirname "$LOG_JSON")"
chmod 755 "$(dirname "$LOG_JSON")" 2>/dev/null || true

# ---------- logging functions ----------
log() {
  jq -cn --arg ts "$(date -Iseconds)" \
        --arg stage "$1" \
        --argjson extra "$2" \
        '$extra + {ts: $ts, stage: $stage}' \
  >> "$LOG_JSON"
  chmod 644 "$LOG_JSON" 2>/dev/null || true
}

fail() {
  echo "Error: $1" >&2
  log error "{\"msg\": \"$1\"}"
  exit 1
}

# ---------- identification functions ----------
identify_device() {
  local dev="$1"

  if [[ ! -e "$dev" ]]; then
    fail "Device $dev not found"
  fi

  MODEL=$(lsblk -no MODEL "$dev" | tr -s ' ' '_')
  SERIAL=$(lsblk -no SERIAL "$dev" | tr -s ' ' '_')
  local medium_human="${MODEL:-unknown}_${SERIAL:-unknown}"

  SIG_FILE="/tmp/ntt-sig-$$"
  head -c 1M "$dev" > "$SIG_FILE"
  tail -c 1M "$dev" >> "$SIG_FILE"
  local medium_hash=$(b3sum < "$SIG_FILE" | cut -d' ' -f1)
  rm -f "$SIG_FILE"

  log identify "{\"medium_human\": \"$medium_human\", \"medium_hash\": \"$medium_hash\", \"dev\": \"$dev\"}"

  # Return values via echo
  echo "$medium_hash:$medium_human"
}

identify_path() {
  local path="$1"

  if [[ ! -d "$path" ]]; then
    fail "Path $path not found or not a directory"
  fi

  # Generate hash from path only (consistent across runs)
  local medium_human="$(basename "$path")"
  local medium_hash=$(echo -n "$path" | b3sum | cut -d' ' -f1 | cut -c1-32)

  log identify "{\"medium_human\": \"$medium_human\", \"medium_hash\": \"$medium_hash\", \"path\": \"$path\"}"

  # Return values via echo
  echo "$medium_hash:$medium_human"
}

# ---------- health check functions ----------
check_device_health() {
  local dev="$1"

  local SMART_FAIL=$(smartctl -H "$dev" 2>/dev/null | grep -c "FAILED" || echo 0)
  local PROPRIETARY=$(smartctl -i "$dev" 2>/dev/null | grep -Ei "G-RAID|hardware-raid" | wc -l || echo 0)
  local REMOVABLE=$(lsblk -no HOTPLUG "$dev" 2>/dev/null || echo 0)

  local IMAGE_FIRST=false
  if [[ $SMART_FAIL -gt 0 ]] || [[ $PROPRIETARY -gt 0 ]] || [[ "$REMOVABLE" == "1" ]]; then
    IMAGE_FIRST=true
  fi

  log health "{\"image_first\": $IMAGE_FIRST, \"smart_fail\": $SMART_FAIL, \"proprietary\": $PROPRIETARY}"

  # Return the value
  echo "$IMAGE_FIRST"
}

# ---------- database functions ----------
check_duplicate() {
  local medium_hash="$1"
  local force="$2"

  if ! "$force"; then
    EXISTS=$(psql "$DB_URL" -t -A -c "SELECT 1 FROM medium WHERE medium_hash='$medium_hash'" 2>/dev/null || echo "")
    if [[ -n $EXISTS ]]; then
      log skip "{\"reason\": \"already ingested\"}"
      exit 2
    fi
  fi
}

insert_medium() {
  local medium_hash="$1"
  local medium_human="$2"
  local health="${3:-false}"

  psql "$DB_URL" -c "INSERT INTO medium (medium_hash, medium_human, health)
                     VALUES ('$medium_hash', '$medium_human', '${health}')
                     ON CONFLICT DO NOTHING;" 2>/dev/null || true
}

# ---------- mount/unmount functions ----------
mount_device() {
  local dev="$1"
  local medium_hash="$2"
  local image_first="$3"

  if "$image_first"; then
    IMG="$IMAGE_ROOT/${medium_hash}.img"
    MAP="$IMAGE_ROOT/${medium_hash}.map"
    log imager_spawn "{\"img\": \"$IMG\", \"map\": \"$MAP\"}"
    ntt-imager "$dev" "$IMG" "$MAP"
    LOOP=$(losetup -f --show -r "$IMG")
    mkdir -p "/mnt/ntt/${medium_hash}"
    mount -o ro,nodev,nosuid,noatime "$LOOP" "/mnt/ntt/${medium_hash}"
    MNT="/mnt/ntt/${medium_hash}"
  else
    MNT="/mnt/medium/${medium_hash}"
    mkdir -p "$MNT"
    mount -o ro,nodev,nosuid,noatime "$dev" "$MNT"
  fi

  echo "$MNT"
}

unmount_device() {
  local mnt="$1"
  local image_first="$2"
  local medium_hash="$3"

  if "$image_first"; then
    umount "$mnt" 2>/dev/null || true
    IMG="$IMAGE_ROOT/${medium_hash}.img"
    LOOP=$(losetup -j "$IMG" | cut -d: -f1)
    [[ -n "$LOOP" ]] && losetup -d "$LOOP"
  else
    umount "$mnt" 2>/dev/null || true
  fi
}

# ---------- processing functions ----------
run_enum() {
  local mnt="$1"
  local medium_hash="$2"

  RAW="$RAW_ROOT/${medium_hash}.raw"
  log enum_spawn "{\"mnt\": \"$mnt\", \"raw\": \"$RAW\"}"
  ntt-enum "$mnt" "$medium_hash" "$RAW"

  # Make raw file world readable
  chmod 644 "$RAW" 2>/dev/null || true

  echo "$RAW"
}

run_loader() {
  local medium_hash="$1"
  local raw="$2"

  log loader_spawn "{\"raw\": \"$raw\"}"
  ntt-loader "$raw" "$medium_hash"
}

run_copy_workers() {
  local medium_hash="$1"
  local workers="${2:-8}"

  echo "[$(date -Iseconds)] Copy workers not implemented yet - skipping file copying" >&2
  log copy_spawn "{\"workers\": 0, \"status\": \"not_implemented\", \"msg\": \"ntt-copy-worker not yet implemented\"}"

  # TODO: Implement ntt-copy-worker for actual file copying/deduplication
  # This would copy files from source to destination with hash-based deduplication
}

cleanup_image() {
  local medium_hash="$1"

  COPIED=$(psql "$DB_URL" -t -A -c \
    "SELECT count(*) FILTER (WHERE copied) = count(*) FROM inode WHERE medium_hash='$medium_hash'" 2>/dev/null || echo 0)
  if [[ $COPIED -eq 1 ]]; then
    rm -f "$IMAGE_ROOT/${medium_hash}.img" "$IMAGE_ROOT/${medium_hash}.map"
    log image_delete "{\"reason\": \"all_inodes_copied\"}"
  fi
}

# ---------- mode handlers ----------
handle_device_mode() {
  local dev="$1"
  local image_first="$2"
  local force="$3"
  local enum_only="$4"

  # Identify and check health
  local identify_result=$(identify_device "$dev")
  local medium_hash="${identify_result%%:*}"
  local medium_human="${identify_result#*:}"

  check_duplicate "$medium_hash" "$force"
  local IMAGE_FIRST=$(check_device_health "$dev")

  # Insert into database
  insert_medium "$medium_hash" "$medium_human" "$IMAGE_FIRST"

  # Mount and process
  MNT=$(mount_device "$dev" "$medium_hash" "$IMAGE_FIRST")
  RAW=$(run_enum "$MNT" "$medium_hash")

  # Run full pipeline unless --enum-only
  if ! "$enum_only"; then
    run_loader "$medium_hash" "$RAW"
    run_copy_workers "$medium_hash"
  fi

  # Cleanup
  unmount_device "$MNT" "$IMAGE_FIRST" "$medium_hash"
  [[ "$IMAGE_FIRST" == "true" ]] && cleanup_image "$medium_hash"
}

handle_directory_mode() {
  local path="$1"
  local force="$2"
  local enum_only="$3"

  # Identify path
  local identify_result=$(identify_path "$path")
  local medium_hash="${identify_result%%:*}"
  local medium_human="${identify_result#*:}"

  # Check if raw file already exists
  RAW="$RAW_ROOT/${medium_hash}.raw"
  if [[ -f "$RAW" ]] && ! "$force"; then
    fail "Raw file already exists: $RAW (use --force to overwrite)"
  fi

  check_duplicate "$medium_hash" "$force"

  # Insert into database (no health check for paths)
  insert_medium "$medium_hash" "$medium_human" "false"

  # Run enum directly on the path
  RAW=$(run_enum "$path" "$medium_hash")

  # Run full pipeline unless --enum-only
  if ! "$enum_only"; then
    run_loader "$medium_hash" "$RAW"
    run_copy_workers "$medium_hash"
  fi
}

# ---------- load-only mode handler ----------
handle_load_only_mode() {
  local raw_file="$1"

  # Check if raw file exists
  if [[ ! -f "$raw_file" ]]; then
    fail "Raw file not found: $raw_file"
  fi

  # Extract medium_hash from filename (remove path and .raw extension)
  local filename=$(basename "$raw_file")
  local medium_hash="${filename%.raw}"

  # Validate it looks like a hash
  if [[ ! "$medium_hash" =~ ^[a-f0-9]{16,64}$ ]]; then
    fail "Invalid filename format: expected hash.raw, got $filename"
  fi

  echo "[$(date -Iseconds)] Loading raw file: $raw_file (medium_hash: $medium_hash)" >&2
  log load_only_start "{\"raw_file\": \"$raw_file\", \"medium_hash\": \"$medium_hash\"}"

  # Run loader directly (no enum, no copy workers)
  ntt-loader "$raw_file" "$medium_hash"

  log load_only_done "{\"medium_hash\": \"$medium_hash\", \"exit\": 0}"
}

# ---------- argparse ----------
usage() {
  cat <<EOF
Usage:
  sudo $0 /dev/sdX [--enum-only] [--force]           # Device enumeration (PARTIAL)
  sudo $0 /path/to/directory [--enum-only] [--force] # Directory enumeration
  sudo $0 --load-only /path/to/file.raw              # Load .raw into database

Current implementation status:
  ❌ TODO: Device imaging, mounting, health checks
  ✅ WORKING: Directory enumeration → .raw files → PostgreSQL loading
  ✅ WORKING: .raw file loading into database
  ❌ TODO: Copy workers (file copying/deduplication)

Modes:
  /path/to/dir   Enumerate directory, optionally load to database
  /dev/sdX       Enumerate device (basic - no imaging/mounting yet)
  --load-only    Load existing .raw file into PostgreSQL

Options:
  --enum-only    Stop after enumeration (.raw file creation)
  --force        Bypass duplicate checking
  --load-only    Load mode: process existing .raw file
EOF
  exit 1
}

# Parse arguments
[[ $# -ge 1 ]] || usage

# Check for --load-only mode first
if [[ "$1" == "--load-only" ]]; then
  [[ $# -eq 2 ]] || usage
  LOAD_ONLY_MODE=true
  LOAD_ONLY_FILE="$2"
else
  LOAD_ONLY_MODE=false
  TARGET="$1"
  shift

  # Parse flags
  IMAGE_FIRST=false
  FORCE=false
  ENUM_ONLY=false

  for arg in "$@"; do
    case $arg in
      --image-first) IMAGE_FIRST=true ;;
      --force)       FORCE=true ;;
      --enum-only)   ENUM_ONLY=true ;;
      *) usage ;;
    esac
  done
fi

# ---------- main ----------
if [[ "$LOAD_ONLY_MODE" == "true" ]]; then
  handle_load_only_mode "$LOAD_ONLY_FILE"
elif [[ "$TARGET" == /dev/* ]]; then
  handle_device_mode "$TARGET" "$IMAGE_FIRST" "$FORCE" "$ENUM_ONLY"
else
  handle_directory_mode "$TARGET" "$FORCE" "$ENUM_ONLY"
fi

log done "{\"exit\": 0}"
exit 0
