#!/usr/bin/env bash
# Author: PB & Claude
# Date: 2025-10-04
# License: (c) HRDAG, 2025, GPL-2 or newer
#
# ------
# ntt/bin/ntt-imager
#
# Progressive 7-phase ddrescue imaging - never give up until 100% or exhausted
set -euo pipefail

# ---------- Arguments ----------
if [[ $# -lt 3 ]]; then
  cat <<EOF
Usage: $0 <device> <output.img> <mapfile>

Progressive ddrescue imaging with 7 escalating phases.
Runs until 100% rescued or all methods exhausted.

Phases:
  1. Quick first pass (large blocks, ~2-4 hours)
  2. Trimming bad areas (small blocks, ~2-4 hours)
  3. Aggressive scraping (10 retries, ~12-24 hours)
  4. Reverse scraping (20 retries, ~12-24 hours)
  5. Tiny blocks forward (100 retries, ~24-48 hours)
  6. Tiny blocks reverse (100 retries, ~24-48 hours)
  7. Direct disc access (bypass caching, ~12-24 hours)

Exit codes:
  0 = 100% rescued (SUCCESS)
  1 = Exhausted all 7 phases, some sectors unreadable (PARTIAL)
  2 = Error (device not found, disk full, etc.)

Example:
  sudo $0 /dev/sdc /data/fast/img/backup.img /data/fast/img/backup.map
EOF
  exit 2
fi

DEVICE="$1"
OUTPUT="$2"
MAPFILE="$3"
LOGFILE="${OUTPUT%.img}-ddrescue.log"

# ---------- Validation ----------
if [[ ! -e "$DEVICE" ]]; then
  echo "Error: Device $DEVICE not found" >&2
  exit 2
fi

if [[ ! -b "$DEVICE" ]]; then
  echo "Error: $DEVICE is not a block device" >&2
  exit 2
fi

OUTPUT_DIR="$(dirname "$OUTPUT")"
if [[ ! -d "$OUTPUT_DIR" ]]; then
  echo "Error: Output directory $OUTPUT_DIR does not exist" >&2
  exit 2
fi

if [[ ! -w "$OUTPUT_DIR" ]]; then
  echo "Error: Output directory $OUTPUT_DIR is not writable" >&2
  exit 2
fi

# Check for ddrescue
if ! command -v ddrescue &>/dev/null; then
  echo "Error: ddrescue not found. Install with: sudo apt install gddrescue" >&2
  exit 2
fi

# ---------- Helper Functions ----------
START_TIME=$(date +%s)

log() {
  echo "[$(date -Iseconds)] $*" | tee -a "$LOGFILE"
}

cleanup_and_exit() {
  local exit_code="$1"

  # Eject CD/DVD if device is optical drive
  if [[ "$DEVICE" == "/dev/sr0" ]] || [[ "$DEVICE" == "/dev/cdrom" ]]; then
    log "Ejecting optical drive: $DEVICE"
    eject "$DEVICE" 2>&1 | tee -a "$LOGFILE" || log "Warning: Failed to eject $DEVICE"
  fi

  exit "$exit_code"
}

count_unfinished_sectors() {
  local mapfile="$1"
  if [[ ! -f "$mapfile" ]]; then
    echo "0"
    return
  fi

  # Get total size of device from mapfile (all data lines with 3 columns: pos size status)
  # Column 2 is size in hex (0xNNNN), need to convert to decimal
  # Skip comment lines and the current_pos line (has different format)
  local total=$(grep -v '^#' "$mapfile" 2>/dev/null | awk 'NF==3 && $2 ~ /^0x/ {sum+=strtonum($2)} END {print sum+0}')

  # Get rescued size (only lines where column 3 is + and size is hex)
  local rescued=$(grep -v '^#' "$mapfile" 2>/dev/null | awk 'NF==3 && $2 ~ /^0x/ && $3=="+" {sum+=strtonum($2)} END {print sum+0}')

  # Unfinished = total - rescued, convert bytes to sectors
  local unfinished=$(( (total - rescued) / 512 ))
  echo "$unfinished" | tr -d '\n'
}

parse_mapfile_percentage() {
  local mapfile="$1"
  if [[ ! -f "$mapfile" ]]; then
    echo "0.00"
    return
  fi

  # Mapfile format: pos(hex) size(hex) status
  # Status in column 3: + (rescued), - (bad), ? (non-tried), * (non-trimmed), / (non-scraped)
  local rescued=$(grep -v '^#' "$mapfile" 2>/dev/null | awk 'NF==3 && $2 ~ /^0x/ && $3=="+" {sum+=strtonum($2)} END {print sum+0}')
  local total=$(grep -v '^#' "$mapfile" 2>/dev/null | awk 'NF==3 && $2 ~ /^0x/ {sum+=strtonum($2)} END {print sum+0}')

  if [[ $total -eq 0 ]]; then
    echo "0.00"
  else
    echo "scale=2; $rescued * 100 / $total" | bc
  fi
}

check_stalled() {
  local hours="$1"
  local mapfile="$2"
  local stall_file="${mapfile}.stall"

  # Hash the bad sector list to detect changes
  local bad_sectors_hash=$(grep -E '^[?*/-]' "$mapfile" 2>/dev/null | md5sum | cut -d' ' -f1)

  if [[ -f "$stall_file" ]]; then
    local prev_hash=$(cat "$stall_file")
    local prev_time=$(stat -c %Y "$stall_file")
    local curr_time=$(date +%s)
    local elapsed=$(( (curr_time - prev_time) / 3600 ))

    if [[ "$prev_hash" == "$bad_sectors_hash" && $elapsed -ge $hours ]]; then
      return 0  # STALLED
    fi
  fi

  # Update stall tracking
  echo "$bad_sectors_hash" > "$stall_file"
  touch "$stall_file"

  return 1  # NOT stalled
}

run_phase() {
  local phase="$1"
  shift
  local description="$1"
  shift

  log "======================================"
  log "PHASE $phase: $description"
  log "======================================"

  # Run ddrescue with given arguments
  ddrescue "$@" "$DEVICE" "$OUTPUT" "$MAPFILE" 2>&1 | tee -a "$LOGFILE" || true

  local unfinished=$(count_unfinished_sectors "$MAPFILE")
  local pct=$(parse_mapfile_percentage "$MAPFILE")
  log "PHASE $phase COMPLETE: $unfinished sectors remaining (${pct}% rescued)"

  # Check if 100% done
  if [[ $unfinished -eq 0 ]]; then
    local elapsed=$(( ($(date +%s) - START_TIME) / 3600 ))
    log "======================================"
    log "SUCCESS: 100% rescued after $elapsed hours"
    log "======================================"
    cleanup_and_exit 0
  fi
}

# ---------- Initial Status ----------
log "======================================"
log "NTT Progressive Imager Starting"
log "======================================"
log "Device: $DEVICE"
log "Output: $OUTPUT"
log "Mapfile: $MAPFILE"
log "Log: $LOGFILE"

if [[ -f "$MAPFILE" ]]; then
  log "Existing mapfile found - will resume"
  rescued=$(parse_mapfile_percentage "$MAPFILE")
  unfinished=$(count_unfinished_sectors "$MAPFILE")
  log "Current status: ${rescued}% rescued, $unfinished sectors remaining"
fi

# ---------- PHASE 1: Quick First Pass ----------
run_phase 1 "Quick first pass (large blocks, no scraping)" \
  --force \
  --no-scrape \
  --no-trim \
  --idirect \
  --cluster-size=128

# ---------- PHASE 2: Trimming ----------
run_phase 2 "Trimming bad areas (small blocks, 5 retry passes)" \
  --force \
  --no-scrape \
  --idirect \
  --cluster-size=8 \
  --retry-passes=5

# ---------- PHASE 3: Aggressive Scraping ----------
run_phase 3 "Aggressive scraping (10 retries per sector)" \
  --force \
  --idirect \
  --retry-passes=10 \
  --retry-passes=10

# Check for stall after Phase 3
if check_stalled 4 "$MAPFILE"; then
  log "WARNING: No progress for 4 hours, continuing to Phase 4 anyway"
fi

# Check rescue percentage after Phase 3 for early bailouts
rescued_pct=$(parse_mapfile_percentage "$MAPFILE")

# Bailout if excellent recovery (>99%) - no need for expensive phases
if (( $(echo "$rescued_pct > 99" | bc -l) )); then
  elapsed=$(( ($(date +%s) - START_TIME) / 3600 ))
  log "======================================"
  log "EXCELLENT: ${rescued_pct}% rescued after Phase 3 (>99% threshold)"
  log "Skipping phases 4-7 (diminishing returns)"
  log "Total time: $elapsed hours"
  log "======================================"
  cleanup_and_exit 0
fi

# Bailout if disk is likely dead (≤25% rescued after aggressive scraping)
if (( $(echo "$rescued_pct <= 25" | bc -l) )); then
  elapsed=$(( ($(date +%s) - START_TIME) / 3600 ))
  log "======================================"
  log "LIKELY-DEAD: Only ${rescued_pct}% rescued after Phase 3 (≤25% threshold)"
  log "Disk appears severely damaged, skipping phases 4-7"
  log "Total time: $elapsed hours"
  log "======================================"
  cleanup_and_exit 1
fi

log "Rescued ${rescued_pct}% after Phase 3 (26-99%), continuing to Phase 4..."

# ---------- PHASE 4: Reverse Scraping ----------
run_phase 4 "Reverse scraping (4 retries, backwards)" \
  --force \
  --idirect \
  --reverse \
  --retry-passes=4

# Check if we've rescued enough (>99%) - skip expensive phases 5-7
rescued_pct=$(parse_mapfile_percentage "$MAPFILE")
if (( $(echo "$rescued_pct > 99" | bc -l) )); then
  elapsed=$(( ($(date +%s) - START_TIME) / 3600 ))
  log "======================================"
  log "GOOD-ENOUGH: ${rescued_pct}% rescued after Phase 4 (>99% threshold)"
  log "Skipping Phases 5-7 (diminishing returns)"
  log "Total time: $elapsed hours"
  log "======================================"
  cleanup_and_exit 0
fi

log "Rescued ${rescued_pct}% after Phase 4 (≤99%), continuing to expensive phases..."

# ---------- PHASE 5: Tiny Blocks Forward ----------
run_phase 5 "Tiny blocks forward (512-byte reads, 6 retries)" \
  --force \
  --idirect \
  --cluster-size=1 \
  --sector-size=512 \
  --retry-passes=6

# Check if we've rescued enough (>95%) - skip phases 6-7
rescued_pct=$(parse_mapfile_percentage "$MAPFILE")
if (( $(echo "$rescued_pct >= 95" | bc -l) )); then
  elapsed=$(( ($(date +%s) - START_TIME) / 3600 ))
  log "======================================"
  log "GOOD-ENOUGH: ${rescued_pct}% rescued after Phase 5 (≥95% threshold)"
  log "Skipping Phases 6-7 (severely damaged media only)"
  log "Total time: $elapsed hours"
  log "======================================"
  cleanup_and_exit 0
fi

log "Rescued ${rescued_pct}% after Phase 5 (<95%), continuing to phases 6-7 for severely damaged media..."

# ---------- PHASE 6: Tiny Blocks Reverse ----------
run_phase 6 "Tiny blocks reverse (512-byte reads, 100 retries)" \
  --force \
  --idirect \
  --reverse \
  --cluster-size=1 \
  --sector-size=512 \
  --retry-passes=100 \
  --retry-passes=20

# Check for stall after Phases 5-6
if check_stalled 8 "$MAPFILE"; then
  log "WARNING: No progress for 8 hours in Phase 5-6"
fi

# ---------- PHASE 7: Direct Disc Access ----------
run_phase 7 "Direct disc access (bypass all caching, 50 retries)" \
  --force \
  --idirect \
  --odirect \
  --retry-passes=50 \
  --retry-passes=10

# ---------- Final Status ----------
unfinished=$(count_unfinished_sectors "$MAPFILE")
elapsed=$(( ($(date +%s) - START_TIME) / 3600 ))
rescued_pct=$(parse_mapfile_percentage "$MAPFILE")

log "======================================"
if [[ $unfinished -eq 0 ]]; then
  log "SUCCESS: 100% rescued after $elapsed hours and 7 phases"
  log "======================================"
  cleanup_and_exit 0
else
  log "EXHAUSTED: All 7 phases complete after $elapsed hours"
  log "Final status: ${rescued_pct}% rescued, $unfinished sectors unreadable"
  log "======================================"
  cleanup_and_exit 1
fi
