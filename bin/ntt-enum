#!/usr/bin/env bash
# Author: PB and Claude and Kimi
# Date: 2025-09-26
# License: (c) HRDAG, 2025, GPL-2 or newer
#
# ------
# ntt/bin/ntt-enum
#
# NTT raw enumerator – outputs one NUL-rec per dirent
set -euo pipefail

# ---------- argparse ----------
usage() {
  echo "Usage: $0 MOUNT_POINT MEDIUM_HASH OUT.raw"
  exit 1
}
[[ $# -eq 3 ]] || usage
MNT="$1"; MEDIUM_HASH="$2"; OUT="$3"

# ---------- env / config ----------
LOG_JSON="${NTT_ENUM_LOG:-/var/log/ntt/enum.jsonl}"
IGNORE_PATTERNS="${NTT_IGNORE_PATTERNS:-}"
mkdir -p "$(dirname "$LOG_JSON")"
mkdir -p "$(dirname "$OUT")"

# Make directories world readable
chmod 755 "$(dirname "$LOG_JSON")" 2>/dev/null || true
chmod 755 "$(dirname "$OUT")" 2>/dev/null || true

# ---------- JSON helper ----------
log() {
  jq -cn --arg ts "$(date -Iseconds)" \
        --arg stage "$1" \
        --argjson extra "$2" \
        '$extra + {ts: $ts, stage: $stage}' \
  >> "$LOG_JSON"
}

# ---------- sanity checks ----------
if [[ ! -d "$MNT" ]]; then
  log error "{\"msg\": \"mount point not found\", \"mnt\": \"$MNT\"}"
  exit 1
fi

# ---------- enumerate ----------
log start "{\"mnt\": \"$MNT\", \"medium_hash\": \"$MEDIUM_HASH\", \"out\": \"$OUT\"}"

# Build grep filter for ignore patterns if configured
FILTER_CMD="cat"
if [[ -n "$IGNORE_PATTERNS" && -f "$IGNORE_PATTERNS" ]]; then
  # Build extended regex from patterns file (skip comments and empty lines)
  PATTERNS=$(grep -v '^#' "$IGNORE_PATTERNS" | grep -v '^[[:space:]]*$' | paste -sd '|')
  if [[ -n "$PATTERNS" ]]; then
    log filter_enabled "{\"patterns_file\": \"$IGNORE_PATTERNS\"}"
    # Filter out paths matching any pattern (grep -v inverts, -z for null-terminated)
    FILTER_CMD="grep -zv -E '$PATTERNS'"
  fi
fi

# %y file type, %D dev, %i ino, %n nlink, %s size, %Ts mtime-epoch-seconds, %p path
# File types: f=file, d=dir, l=symlink, b=block, c=char, p=fifo, s=socket
# Suppress find errors (inaccessible paths, corrupted filenames) - we skip those files
# Disable pipefail temporarily because pv can exit non-zero on broken pipe which is normal
set +e
find "$MNT" -xdev -printf '%y\034%D\034%i\034%n\034%s\034%Ts\034%p\0' 2>/dev/null \
| eval "$FILTER_CMD" \
| tee >(tr -cd '\0' | wc -c > /tmp/ntt-count-$$) \
| pv -0 -l -f \
> "$OUT"
set -e

# Wait for process substitution to complete
sleep 1

# Check if we got output - if we have rows, it worked regardless of exit codes
ROWS=$(cat /tmp/ntt-count-$$ 2>/dev/null || echo "0")
# Ensure ROWS is a number (default to 0 if empty or non-numeric)
ROWS=${ROWS:-0}
rm -f /tmp/ntt-count-$$ 2>/dev/null || true

if [ "$ROWS" -gt 0 ] && [ -f "$OUT" ]; then
  # Success - we got records and the output file exists
  chmod 644 "$OUT" 2>/dev/null || true

  log enum_complete "{\"rows\": $ROWS, \"out\": \"$OUT\"}"
  echo "[$(date -Iseconds)] ✓ Enumeration complete: $ROWS records written to $(basename "$OUT")" >&2
  log done "{\"rows\": $ROWS, \"exit\": 0}"

  chmod 644 "$LOG_JSON" 2>/dev/null || true
  echo "[$(date -Iseconds)] ✓ Logged success to $LOG_JSON" >&2
  exit 0
else
  # Error - no records or no output file
  log error "{\"msg\": \"enumeration failed - no records or output file\", \"rows\": $ROWS, \"out\": \"$OUT\"}"
  echo "[$(date -Iseconds)] ✗ Enumeration failed: $ROWS records, output exists: $([ -f "$OUT" ] && echo yes || echo no)" >&2
  exit 1
fi
