#!/usr/bin/env bash
# Author: PB and Claude and Kimi
# Date: 2025-09-26
# License: (c) HRDAG, 2025, GPL-2 or newer
#
# ------
# ntt/bin/ntt-enum
#
# NTT raw enumerator – outputs one NUL-rec per dirent
#
# bash-logger: INTEGRATED (2025-11-05)

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$(cd "$SCRIPT_DIR/../lib" && pwd)"

LOG_FILE="${NTT_ENUM_LOG:-/var/log/ntt/enum.jsonl}"

# ---------- argparse ----------
usage() {
  echo "Usage: $0 MOUNT_POINT MEDIUM_HASH OUT.raw"
  exit 1
}
[[ $# -eq 3 ]] || usage
MNT="$1"; MEDIUM_HASH="$2"; OUT="$3"

# Initialize logging
# shellcheck source=../lib/bash-logger.sh
source "$LIB_DIR/bash-logger.sh"
log_init || exit 1

# ---------- env / config ----------
IGNORE_PATTERNS="${NTT_IGNORE_PATTERNS:-}"
mkdir -p "$(dirname "$LOG_FILE")"
mkdir -p "$(dirname "$OUT")"

# Make directories world readable
chmod 755 "$(dirname "$LOG_FILE")" 2>/dev/null || true
chmod 755 "$(dirname "$OUT")" 2>/dev/null || true

# ---------- JSON helper ----------
log_stage() {
  # Structured stage logging via bash-logger
  log_info "$1" "$2"
}

# ---------- sanity checks ----------
if [[ ! -d "$MNT" ]]; then
  log_stage error "{\"msg\": \"mount point not found\", \"mnt\": \"$MNT\"}"
  exit 1
fi

# ---------- enumerate ----------
log_stage start "{\"mnt\": \"$MNT\", \"medium_hash\": \"$MEDIUM_HASH\", \"out\": \"$OUT\"}"

# Build grep filter for ignore patterns if configured
FILTER_CMD="cat"
if [[ -n "$IGNORE_PATTERNS" && -f "$IGNORE_PATTERNS" ]]; then
  # Build extended regex from patterns file (skip comments and empty lines)
  PATTERNS=$(grep -v '^#' "$IGNORE_PATTERNS" | grep -v '^[[:space:]]*$' | paste -sd '|')
  if [[ -n "$PATTERNS" ]]; then
    log_stage filter_enabled "{\"patterns_file\": \"$IGNORE_PATTERNS\"}"
    # Filter out paths matching any pattern (grep -v inverts, -z for null-terminated)
    FILTER_CMD="grep -zv -E '$PATTERNS'"
  fi
fi

# %y file type, %D dev, %i ino, %n nlink, %s size, %Ts mtime-epoch-seconds, %p path
# File types: f=file, d=dir, l=symlink, b=block, c=char, p=fifo, s=socket
# Suppress find errors (inaccessible paths, corrupted filenames) - we skip those files
# Disable pipefail temporarily because pv can exit non-zero on broken pipe which is normal
set +e
find "$MNT" -xdev -printf '%y\034%D\034%i\034%n\034%s\034%Ts\034%p\0' 2>/dev/null \
| eval "$FILTER_CMD" \
| tee >(tr -cd '\0' | wc -c > /tmp/ntt-count-$$) \
| pv -0 -l -f \
> "$OUT"
set -e

# Wait for process substitution to complete
sleep 1

# Check if we got output - if we have rows, it worked regardless of exit codes
ROWS=$(cat /tmp/ntt-count-$$ 2>/dev/null || echo "0")
# Ensure ROWS is a number (default to 0 if empty or non-numeric)
ROWS=${ROWS:-0}
rm -f /tmp/ntt-count-$$ 2>/dev/null || true

if [ "$ROWS" -gt 0 ] && [ -f "$OUT" ]; then
  # Success - we got records and the output file exists
  chmod 644 "$OUT" 2>/dev/null || true

  log_stage enum_complete "{\"rows\": $ROWS, \"out\": \"$OUT\"}"
  echo "[$(date -Iseconds)] ✓ Enumeration complete: $ROWS records written to $(basename "$OUT")" >&2
  log_stage done "{\"rows\": $ROWS, \"exit\": 0}"

  chmod 644 "$LOG_FILE" 2>/dev/null || true
  echo "[$(date -Iseconds)] ✓ Logged success to $LOG_FILE" >&2
  exit 0
else
  # Error - no records or no output file
  log_stage error "{\"msg\": \"enumeration failed - no records or output file\", \"rows\": $ROWS, \"out\": \"$OUT\"}"
  echo "[$(date -Iseconds)] ✗ Enumeration failed: $ROWS records, output exists: $([ -f "$OUT" ] && echo yes || echo no)" >&2
  exit 1
fi
