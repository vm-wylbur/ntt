#!/bin/bash
# ntt-copy-workers: Launch K parallel ntt-copier workers with optional limit N
# Handles ^C signal to cleanly terminate all workers
# Leaves progress monitoring to separate dashboard script

set -euo pipefail

# Load NTT environment (only if vars not already set)
if [[ -f ~/.config/ntt/ntt.env ]]; then
    # Save existing vars
    SAVED_DB_URL="${NTT_DB_URL:-}"
    SAVED_PGUSER="${PGUSER:-}"
    SAVED_ARCHIVE="${NTT_ARCHIVE_ROOT:-}"
    SAVED_BYHASH="${NTT_BY_HASH_ROOT:-}"

    source ~/.config/ntt/ntt.env

    # Restore if they were set before
    [[ -n "$SAVED_DB_URL" ]] && NTT_DB_URL="$SAVED_DB_URL"
    [[ -n "$SAVED_PGUSER" ]] && PGUSER="$SAVED_PGUSER"
    [[ -n "$SAVED_ARCHIVE" ]] && NTT_ARCHIVE_ROOT="$SAVED_ARCHIVE"
    [[ -n "$SAVED_BYHASH" ]] && NTT_BY_HASH_ROOT="$SAVED_BYHASH"
fi

# Default values
WORKERS=4
LIMIT=""
DRY_RUN=""
MEDIUM_HASH=""
VERBOSE=false
PIDS=()
WORKER_IDS=()

# Parse arguments
usage() {
    cat <<EOF
Usage: $(basename "$0") -m MEDIUM_HASH [OPTIONS]

Launch parallel ntt-copier workers with signal handling (batch mode).

Options:
    -m, --medium-hash H     Medium hash to process (REQUIRED)
    -w, --workers K         Number of parallel workers (default: 4)
    -l, --limit N           Process limit per worker
    -d, --dry-run N         Dry-run mode with N items per worker
    -v, --verbose           Show detailed output
    -h, --help              Show this help

Examples:
    $(basename "$0") -m 36937238a0c0c4b1 -w 8          # 8 workers on specific medium
    $(basename "$0") -m 36937238a0c0c4b1 -w 4 -l 100   # 4 workers, 100 items each
    $(basename "$0") -m 36937238a0c0c4b1 -w 8 -d 50    # 8 workers, dry-run 50 items each

Finding media hashes:
    ntt-list-media --path-prefix /data/staging

Signal handling:
    ^C (SIGINT) cleanly terminates all workers
EOF
    exit 0
}

# Parse command line
while [[ $# -gt 0 ]]; do
    case "$1" in
        -w|--workers)
            WORKERS="$2"
            shift 2
            ;;
        --workers=*)
            WORKERS="${1#*=}"
            shift
            ;;
        -l|--limit)
            LIMIT="$2"
            shift 2
            ;;
        --limit=*)
            LIMIT="${1#*=}"
            shift
            ;;
        -d|--dry-run)
            DRY_RUN="$2"
            shift 2
            ;;
        --dry-run=*)
            DRY_RUN="${1#*=}"
            shift
            ;;
        -m|--medium-hash)
            MEDIUM_HASH="$2"
            shift 2
            ;;
        --medium-hash=*)
            MEDIUM_HASH="${1#*=}"
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -h|--help)
            usage
            ;;
        *)
            echo "Unknown option: $1" >&2
            usage
            ;;
    esac
done

# Validate required arguments
if [[ -z "$MEDIUM_HASH" ]]; then
    echo "Error: --medium-hash is required" >&2
    usage
fi

# Validate workers is a number
if ! [[ "$WORKERS" =~ ^[0-9]+$ ]]; then
    echo "Error: Workers must be a positive integer" >&2
    exit 1
fi

# Check for mutual exclusivity
if [[ -n "$LIMIT" && -n "$DRY_RUN" ]]; then
    echo "Error: --limit and --dry-run are mutually exclusive" >&2
    exit 1
fi

# Build worker command (pass env vars explicitly since sudo -E is ignored)
# Note: Don't pass PGOPTIONS here - ntt-copier.py sets search_path from it internally
WORKER_CMD="sudo PGUSER=${PGUSER:-$USER} NTT_DB_URL=${NTT_DB_URL:-postgresql:///copyjob} SUDO_USER=${SUDO_USER:-$USER}"
[[ -n "${PGPASSWORD:-}" ]] && WORKER_CMD="$WORKER_CMD PGPASSWORD='$PGPASSWORD'"
[[ -n "${NTT_ARCHIVE_ROOT:-}" ]] && WORKER_CMD="$WORKER_CMD NTT_ARCHIVE_ROOT='$NTT_ARCHIVE_ROOT'"
[[ -n "${NTT_BY_HASH_ROOT:-}" ]] && WORKER_CMD="$WORKER_CMD NTT_BY_HASH_ROOT='$NTT_BY_HASH_ROOT'"
[[ -n "${NTT_SEARCH_PATH:-}" ]] && WORKER_CMD="$WORKER_CMD NTT_SEARCH_PATH='$NTT_SEARCH_PATH'"
WORKER_CMD="$WORKER_CMD /home/pball/.local/bin/uv run /home/pball/projects/ntt/bin/ntt-copier.py --medium-hash=$MEDIUM_HASH"

if [[ -n "$LIMIT" ]]; then
    WORKER_CMD="$WORKER_CMD --limit=$LIMIT"
elif [[ -n "$DRY_RUN" ]]; then
    WORKER_CMD="$WORKER_CMD --dry-run --limit=$DRY_RUN"
fi

# Ensure medium has health='ok' so workers can find work
if [[ -n "${SUDO_USER:-}" ]]; then
    sudo -u "$SUDO_USER" psql "${NTT_DB_URL:-postgresql:///copyjob}" -c "UPDATE medium SET health = 'ok' WHERE medium_hash = '$MEDIUM_HASH';" >/dev/null 2>&1 || true
else
    psql "${NTT_DB_URL:-postgresql:///copyjob}" -c "UPDATE medium SET health = 'ok' WHERE medium_hash = '$MEDIUM_HASH';" >/dev/null 2>&1 || true
fi

# Signal handler for clean shutdown
cleanup() {
    echo -e "\n[$(date '+%H:%M:%S')] Received interrupt signal, stopping workers..."

    # Send SIGTERM to all workers
    for pid in "${PIDS[@]}"; do
        if ps -p "$pid" > /dev/null 2>&1; then
            echo "[$(date '+%H:%M:%S')] Stopping worker $pid"
            sudo kill -TERM "$pid" 2>/dev/null || true
        fi
    done

    # Wait briefly for graceful shutdown
    sleep 2

    # Force kill any remaining
    for pid in "${PIDS[@]}"; do
        if ps -p "$pid" > /dev/null 2>&1; then
            echo "[$(date '+%H:%M:%S')] Force stopping worker $pid"
            sudo kill -KILL "$pid" 2>/dev/null || true
        fi
    done

    # Unmount and cleanup per-worker tmpfs
    for wid in "${WORKER_IDS[@]}"; do
        WORKER_TMPFS="/tmp/ram/${wid}"
        if mountpoint -q "$WORKER_TMPFS" 2>/dev/null; then
            echo "[$(date '+%H:%M:%S')] Unmounting tmpfs at $WORKER_TMPFS"
            sudo umount "$WORKER_TMPFS" 2>/dev/null || true
            sudo rmdir "$WORKER_TMPFS" 2>/dev/null || true
        fi
    done

    echo "[$(date '+%H:%M:%S')] All workers stopped and tmpfs unmounted"
    exit 0
}

# Set up signal trap for interrupt/terminate AND normal exit
trap cleanup SIGINT SIGTERM EXIT

# Launch workers
echo "[$(date '+%H:%M:%S')] Starting $WORKERS workers for medium $MEDIUM_HASH..."
if [[ -n "$LIMIT" ]]; then
    echo "[$(date '+%H:%M:%S')] Limit: $LIMIT items per worker"
elif [[ -n "$DRY_RUN" ]]; then
    echo "[$(date '+%H:%M:%S')] Dry-run: $DRY_RUN items per worker"
fi

for ((i=1; i<=WORKERS; i++)); do
    WORKER_ID="worker-$(printf '%02d' $i)"
    LOG_FILE="/tmp/ntt-${WORKER_ID}.log"

    if $VERBOSE; then
        echo "[$(date '+%H:%M:%S')] Launching $WORKER_ID"
    fi

    # Pre-create log file with correct permissions (as root since worker runs as root)
    sudo touch "$LOG_FILE"
    sudo chmod 666 "$LOG_FILE"

    # Create and mount per-worker tmpfs BEFORE launching (128MB for files <100MB)
    WORKER_TMPFS="/tmp/ram/${WORKER_ID}"
    sudo mkdir -p "$WORKER_TMPFS"

    # Only mount if not already mounted (prevents stacking)
    if ! mountpoint -q "$WORKER_TMPFS" 2>/dev/null; then
        sudo mount -t tmpfs -o size=128M,mode=1777 tmpfs "$WORKER_TMPFS"
        if $VERBOSE; then
            echo "[$(date '+%H:%M:%S')] Mounted 128MB tmpfs at $WORKER_TMPFS"
        fi
    else
        if $VERBOSE; then
            echo "[$(date '+%H:%M:%S')] Tmpfs already mounted at $WORKER_TMPFS, reusing"
        fi
    fi

    # Launch worker in background with worker_id, redirect output to logs
    $WORKER_CMD --worker-id="$WORKER_ID" > "$LOG_FILE" 2>&1 &

    WORKER_PID=$!
    PIDS+=($WORKER_PID)
    WORKER_IDS+=($WORKER_ID)
done

echo "[$(date '+%H:%M:%S')] Launched ${#PIDS[@]} workers with PIDs: ${PIDS[*]}"

# Save PIDs to file for monitoring/stopping
PID_FILE="/tmp/ntt-workers.pids"
sudo touch "$PID_FILE"
sudo chmod 666 "$PID_FILE"
printf "%s\n" "${PIDS[@]}" > "$PID_FILE"

echo "[$(date '+%H:%M:%S')] Workers launched successfully"
echo "[$(date '+%H:%M:%S')] PIDs saved to: $PID_FILE"
echo "[$(date '+%H:%M:%S')] Monitor progress: ntt-dashboard"
echo "[$(date '+%H:%M:%S')] Stop workers: ntt-stop-workers"
echo ""
echo "Note: Workers are running in background. Tmpfs cleanup happens via:"
echo "  - Signal handler on ^C or kill"
echo "  - Auto-cleanup on tmpfs unmount (files deleted automatically)"
echo "  - Manual cleanup: ntt-stop-workers"

# Remove EXIT trap now that workers are launched - cleanup is manual or via signals
trap - EXIT
