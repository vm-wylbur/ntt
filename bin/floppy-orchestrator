#!/usr/bin/env bash
# Author: PB & Claude
# Date: 2025-10-18
# License: (c) HRDAG, 2025, GPL-2 or newer
#
# ------
# floppy-orchestrator
#
# Floppy disk reading orchestrator using Greaseweazle
set -euo pipefail

# ---------- config ----------
FLOPPY_ROOT="${FLOPPY_ROOT:-/data/fast/floppies}"
DISK_ROOT="$FLOPPY_ROOT/disks"
EVENT_LOG="$FLOPPY_ROOT/floppy-orchestrator.jsonl"
LOG_FILE=""  # Set per-disk in main()

# Default gw settings
DEFAULT_DRIVE="B"
DEFAULT_FORMAT="ibm.1440"
FLUX_REVS=5

# ---------- logging functions ----------
log() {
  local msg="[$(date -Iseconds)] $*"
  if [[ -n "$LOG_FILE" ]]; then
    echo "$msg" | tee -a "$LOG_FILE" >&2
  else
    echo "$msg" >&2
  fi
}

log_event() {
  jq -cn --arg ts "$(date -Iseconds)" \
        --arg stage "$1" \
        --argjson extra "$2" \
        '$extra + {ts: $ts, stage: $stage}' \
  >> "$EVENT_LOG"
  chmod 644 "$EVENT_LOG" 2>/dev/null || true
}

fail() {
  log "Error: $1"
  log_event error "{\"msg\": \"$1\"}"
  exit 1
}

# ---------- hash functions ----------
generate_session_hash() {
  local timestamp="$1"
  local message="$2"
  local sequence="${3:-}"

  echo -n "${timestamp}|${message}|${sequence}" | b3sum | cut -d' ' -f1 | cut -c1-32
}

compute_content_hash() {
  local img_file="$1"

  if [[ ! -f "$img_file" ]]; then
    echo ""
    return 1
  fi

  # Hash entire .img file (floppy images are small ~1.4MB)
  b3sum "$img_file" | cut -d' ' -f1 | cut -c1-32
}

# ---------- gw output parsing ----------
parse_gw_output() {
  local output="$1"

  # Parse "Found X sectors of Y (Z%)" line
  # Example: "Found 2857 sectors of 2880 (99%)"
  local found_line=$(echo "$output" | grep "^Found .* sectors of .* (.*%)$" || echo "")

  if [[ -z "$found_line" ]]; then
    # No sector summary found - assume complete failure
    echo "0:0:failed"
    return
  fi

  # Extract numbers: "Found 2857 sectors of 2880 (99%)"
  local sectors_found=$(echo "$found_line" | sed -n 's/^Found \([0-9]*\) sectors of .*/\1/p')
  local sectors_total=$(echo "$found_line" | sed -n 's/^Found [0-9]* sectors of \([0-9]*\) .*/\1/p')

  # Determine status based on percentage
  local status="failed"
  if [[ $sectors_found -eq $sectors_total ]]; then
    status="success"
  elif [[ $sectors_total -gt 0 ]]; then
    # Calculate percentage: found * 100 / total
    local percent=$((sectors_found * 100 / sectors_total))
    if [[ $percent -ge 95 ]]; then
      status="partial"
    else
      status="failed"
    fi
  fi

  echo "${sectors_found}:${sectors_total}:${status}"
}

# ---------- stage functions ----------
stage_read() {
  local session_hash="$1"
  local drive="$2"
  local format="$3"
  local img_path="$4"

  log "======================================"
  log "STAGE: Read Floppy"
  log "======================================"
  log "Drive: $drive"
  log "Format: $format"
  log "Output: $img_path"

  log_event read_start "{\"session_hash\": \"$session_hash\", \"drive\": \"$drive\", \"format\": \"$format\"}"

  # Run gw read and capture output
  local gw_cmd="gw read --drive=$drive --format=$format \"$img_path\""
  log "Running: $gw_cmd"

  local gw_output_file="/tmp/gw-output-$$"
  local exit_code=0

  # Capture output while also displaying it (suppress stdout to avoid contaminating return value)
  if gw read --drive="$drive" --format="$format" "$img_path" 2>&1 | tee -a "$LOG_FILE" "$gw_output_file" >&2; then
    exit_code=0
  else
    exit_code=$?
  fi

  # Parse sector statistics
  local gw_output=$(cat "$gw_output_file")
  local parse_result=$(parse_gw_output "$gw_output")
  rm -f "$gw_output_file"

  # Extract: sectors_found:sectors_total:status
  local sectors_found="${parse_result%%:*}"
  local temp="${parse_result#*:}"
  local sectors_total="${temp%%:*}"
  local read_status="${temp#*:}"

  log "Sector stats: $sectors_found/$sectors_total ($read_status)"

  # Log event based on status
  if [[ "$read_status" == "success" ]]; then
    log "Read complete: 100% recovered"
    log_event read_success "{\"session_hash\": \"$session_hash\", \"sectors\": \"$sectors_found/$sectors_total\"}"
  elif [[ "$read_status" == "partial" ]]; then
    log "Read partial: some sectors missing (95-99% recovered)"
    log_event read_partial "{\"session_hash\": \"$session_hash\", \"sectors\": \"$sectors_found/$sectors_total\"}"
  else
    log "Read failed: significant data loss (<95% recovered)"
    log_event read_failed "{\"session_hash\": \"$session_hash\", \"sectors\": \"$sectors_found/$sectors_total\", \"exit_code\": $exit_code}"
  fi

  # Return: sectors_found:sectors_total:status
  echo "$parse_result"
  return 0
}

stage_flux_capture() {
  local session_hash="$1"
  local drive="$2"
  local flux_path="$3"

  log "======================================"
  log "STAGE: Flux Capture (fallback)"
  log "======================================"
  log "Drive: $drive"
  log "Revolutions: $FLUX_REVS"
  log "Output: $flux_path"

  log_event flux_start "{\"session_hash\": \"$session_hash\", \"revs\": $FLUX_REVS}"

  # Single flux capture with multiple revolutions
  if gw read --drive="$drive" --revs="$FLUX_REVS" "$flux_path" 2>&1 | tee -a "$LOG_FILE" >&2; then
    log "Flux capture completed successfully"
  else
    log "WARNING: Flux capture failed"
  fi

  log_event flux_complete "{\"session_hash\": \"$session_hash\"}"
}

# ---------- metadata functions ----------
write_metadata() {
  local session_hash="$1"
  local content_hash="$2"
  local timestamp="$3"
  local message="$4"
  local sequence="$5"
  local read_status="$6"
  local drive="$7"
  local format="$8"
  local exit_code="$9"
  local img_file="${10}"
  local scp_files="${11}"  # JSON array string
  local sectors_found="${12:-0}"
  local sectors_total="${13:-0}"

  local metadata_file="metadata.json"

  log "Writing metadata to $metadata_file"

  # Compute diagnostics
  local img_size=0
  if [[ -f "$img_file" ]]; then
    img_size=$(stat -c %s "$img_file")
  fi

  # Validate numeric parameters
  [[ -z "$sectors_found" ]] && sectors_found=0
  [[ -z "$sectors_total" ]] && sectors_total=0
  [[ -z "$exit_code" ]] && exit_code=0
  [[ -z "$img_size" ]] && img_size=0

  # Build JSON
  jq -n \
    --arg session_hash "$session_hash" \
    --arg content_hash "$content_hash" \
    --arg timestamp "$timestamp" \
    --arg message "$message" \
    --argjson sequence "$sequence" \
    --arg read_status "$read_status" \
    --arg drive "$drive" \
    --arg format "$format" \
    --argjson exit_code "$exit_code" \
    --arg img_file "$img_file" \
    --argjson scp_files "$scp_files" \
    --arg log_file "${session_hash}.log" \
    --argjson img_size "$img_size" \
    --argjson flux_revs "$FLUX_REVS" \
    --argjson sectors_found "$sectors_found" \
    --argjson sectors_total "$sectors_total" \
    '{
      session_hash: $session_hash,
      content_hash: (if $content_hash == "" then null else $content_hash end),
      timestamp: $timestamp,
      message: $message,
      sequence: $sequence,
      read_status: $read_status,
      gw: {
        drive: $drive,
        format: $format,
        exit_code: $exit_code
      },
      files: {
        img: (if $img_file != "" then $img_file else null end),
        scp: $scp_files,
        log: $log_file
      },
      diagnostics: {
        img_size_bytes: $img_size,
        flux_revs: $flux_revs,
        sectors_found: $sectors_found,
        sectors_total: $sectors_total
      }
    }' > "$metadata_file"

  chmod 644 "$metadata_file" 2>/dev/null || true
  log "Metadata written successfully"
}

show_disks() {
  echo "HASH   | N | STATUS  | FLUX | MRGD | SECTORS     | MESSAGE"
  echo "-------|---|---------|------|------|-------------|$(printf '%.0s-' {1..50})"

  # Build index of all reads grouped by content_hash
  local temp_index="/tmp/floppy-index-$$"
  local temp_file="/tmp/floppy-show-$$"
  > "$temp_index"
  > "$temp_file"

  for meta in "$DISK_ROOT"/*/metadata.json; do
    [[ -f "$meta" ]] || continue

    local dir=$(dirname "$meta")
    local session_hash=$(jq -r '.session_hash' "$meta" 2>/dev/null || echo "")
    local content_hash=$(jq -r '.content_hash' "$meta" 2>/dev/null || echo "")
    local status=$(jq -r '.read_status' "$meta" 2>/dev/null || echo "unknown")
    local message=$(jq -r '.message' "$meta" 2>/dev/null || echo "")
    local sectors_found=$(jq -r '.diagnostics.sectors_found // 0' "$meta" 2>/dev/null || echo "0")
    local sectors_total=$(jq -r '.diagnostics.sectors_total // 0' "$meta" 2>/dev/null || echo "0")

    # Skip entries with missing critical data
    [[ -z "$message" ]] && continue
    [[ -z "$session_hash" ]] && continue

    # Use session_hash if content_hash is missing/null
    [[ -z "$content_hash" || "$content_hash" == "null" ]] && content_hash="$session_hash"

    # Fallback: parse log file if metadata is missing sector info
    if [[ $sectors_found -eq 0 && $sectors_total -eq 0 ]]; then
      local log_file=$(jq -r '.files.log' "$meta" 2>/dev/null)
      if [[ -n "$log_file" && -f "$dir/$log_file" ]]; then
        local found_line=$(grep "^Found .* sectors of .* (.*)$" "$dir/$log_file" 2>/dev/null || echo "")
        if [[ -n "$found_line" ]]; then
          sectors_found=$(echo "$found_line" | sed -n 's/^Found \([0-9]*\) sectors of .*/\1/p')
          sectors_total=$(echo "$found_line" | sed -n 's/^Found [0-9]* sectors of \([0-9]*\) .*/\1/p')
        fi
      fi
    fi

    # Calculate percentage
    local percent=0
    if [[ $sectors_total -gt 0 ]]; then
      percent=$((sectors_found * 100 / sectors_total))
    fi

    # Re-categorize status based on sector data (fix old reads)
    if [[ $sectors_total -gt 0 ]]; then
      if [[ $sectors_found -eq $sectors_total ]]; then
        status="success"
      elif [[ $percent -ge 95 ]]; then
        status="partial"
      else
        status="failed"
      fi
    fi

    # Check for flux files (any .scp file in directory)
    local flux_status="    "  # 4 spaces for "no flux"
    if ls "$dir"/*.scp 1>/dev/null 2>&1; then
      flux_status="FLUX"
    elif [[ "$status" == "partial" || "$status" == "failed" ]]; then
      flux_status="NEED"  # Partial/failed but no flux captured yet
    fi

    # Check for analysis.json (floppy-recover-best-img has been run)
    local analyzed_status="    "  # 4 spaces for "not analyzed"
    if [[ -f "$dir/analysis.json" ]]; then
      analyzed_status="DONE"
    fi

    # Extract first 6 chars of session_hash
    local hash_prefix="${session_hash:0:6}"

    # Sort order: failed (1), partial (2), success (3)
    local sort_key=3
    [[ "$status" == "failed" ]] && sort_key=1
    [[ "$status" == "partial" ]] && sort_key=2

    # Store in index: message|session_hash|percent|status|flux_status|analyzed_status|sectors_found|sectors_total|sort_key|hash_prefix|dir
    printf "%s|%s|%d|%s|%s|%s|%d|%d|%d|%s|%s\n" \
      "$message" "$session_hash" "$percent" "$status" "$flux_status" "$analyzed_status" \
      "$sectors_found" "$sectors_total" "$sort_key" "$hash_prefix" "$dir" \
      >> "$temp_index"
  done

  # Process index: find best read for each message (physical disk)
  local prev_message=""
  local best_percent=0
  local attempt_count=0
  local has_any_flux=false
  local has_any_analyzed=false

  # Track best values across attempts
  local best_hash_prefix=""
  local best_status=""
  local best_sectors_found=0
  local best_sectors_total=0
  local best_sort_key=0

  while IFS='|' read -r message session_hash percent status flux_status analyzed_status sectors_found sectors_total sort_key hash_prefix dir; do
    if [[ "$message" != "$prev_message" ]]; then
      # New disk - output previous best if exists
      if [[ -n "$prev_message" ]]; then
        # Rebuild line with final attempt count, flux status, and analyzed status
        local display_flux="NEED"
        [[ "$has_any_flux" == "true" ]] && display_flux="FLUX"
        [[ "$best_status" == "success" ]] && display_flux="    "

        local display_analyzed="    "
        [[ "$has_any_analyzed" == "true" ]] && display_analyzed="DONE"

        # Truncate message to 50 characters
        local truncated_message="$prev_message"
        if [[ ${#truncated_message} -gt 50 ]]; then
          truncated_message="${truncated_message:0:47}..."
        fi

        printf "%d|%s | %d | %-7s | %-4s | %-4s | %4d/%4d | %s\n" \
          "$best_sort_key" "$best_hash_prefix" "$attempt_count" "$best_status" "$display_flux" "$display_analyzed" \
          "$best_sectors_found" "$best_sectors_total" "$truncated_message" \
          >> "$temp_file"
      fi

      # Reset for new disk
      prev_message="$message"
      best_percent=$percent
      best_hash_prefix="$hash_prefix"
      best_status="$status"
      best_sectors_found=$sectors_found
      best_sectors_total=$sectors_total
      best_sort_key=$sort_key
      attempt_count=1
      has_any_flux=false
      has_any_analyzed=false
      [[ "$flux_status" == "FLUX" ]] && has_any_flux=true
      [[ "$analyzed_status" == "DONE" ]] && has_any_analyzed=true
    else
      # Same disk - another attempt
      attempt_count=$((attempt_count + 1))
      [[ "$flux_status" == "FLUX" ]] && has_any_flux=true
      [[ "$analyzed_status" == "DONE" ]] && has_any_analyzed=true

      # Update best if this is better (compare sectors_found, not percent)
      if [[ $sectors_found -gt $best_sectors_found ]]; then
        best_percent=$percent
        best_hash_prefix="$hash_prefix"
        best_status="$status"
        best_sectors_found=$sectors_found
        best_sectors_total=$sectors_total
        best_sort_key=$sort_key
      fi
    fi
  done < <(sort -t'|' -k1,1 "$temp_index")

  # Output final best (last disk in list)
  if [[ -n "$prev_message" ]]; then
    local display_flux="NEED"
    [[ "$has_any_flux" == "true" ]] && display_flux="FLUX"
    [[ "$best_status" == "success" ]] && display_flux="    "

    local display_analyzed="    "
    [[ "$has_any_analyzed" == "true" ]] && display_analyzed="DONE"

    # Truncate message to 50 characters
    local truncated_message="$prev_message"
    if [[ ${#truncated_message} -gt 50 ]]; then
      truncated_message="${truncated_message:0:47}..."
    fi

    printf "%d|%s | %d | %-7s | %-4s | %-4s | %4d/%4d | %s\n" \
      "$best_sort_key" "$best_hash_prefix" "$attempt_count" "$best_status" "$display_flux" "$display_analyzed" \
      "$best_sectors_found" "$best_sectors_total" "$truncated_message" \
      >> "$temp_file"
  fi

  # Count totals by status and flux BEFORE removing temp file
  local total=$(wc -l < "$temp_file" 2>/dev/null || echo "0")
  local need_flux=$(grep -c "| NEED |" "$temp_file" 2>/dev/null || echo "0")
  local has_flux=$(grep -c "| FLUX |" "$temp_file" 2>/dev/null || echo "0")
  local analyzed=$(grep -c "| DONE |" "$temp_file" 2>/dev/null || echo "0")

  # Sort and display (failed first, then partial, then success)
  sort -t'|' -k1,1n "$temp_file" | cut -d'|' -f2-
  rm -f "$temp_file" "$temp_index"

  echo ""
  echo "Total disks: $total | Need flux: $need_flux | Has flux: $has_flux | Analyzed: $analyzed"
}

# ---------- argparse ----------
usage() {
  cat <<EOF
Usage:
  $0 --message <description> [options]    # Read a floppy disk
  $0 --show                                # Show status of all disks

Orchestrates floppy disk reading with Greaseweazle.
Creates session-based directory with .img and metadata.

Read Mode:
  --message TEXT    Description of the disk (stored as metadata) [REQUIRED]
  --seq NUM         Sequence number (for disk sets)
  --drive DRIVE     Floppy drive (default: B)
  --format FORMAT   Disk format (default: ibm.1440)

Show Mode:
  --show            Display status report of all disks (sorted by status)

Read Status:
  success  = 100% sectors recovered
  partial  = 95-99% sectors recovered (flux capture also saved)
  failed   = <95% sectors recovered (flux capture also saved)

Flux Capture:
  - Only for partial/failed reads
  - Single pass with 5 revolutions
  - ~80-120 MB per disk (captures raw magnetic flux)

Examples:
  $0 --message "WordPerfect 5.1 disk 1/4"
  $0 --message "backup from attic" --seq 7
  $0 --message "game disk" --format ibm.720 --drive A
  $0 --show

Outputs:
  Directory: $DISK_ROOT/{session_hash}/
  Files: {hash}.img (always created if gw produces output)
         {hash}.scp (flux capture for partial/failed reads)
         {hash}.log (console output)
         metadata.json (structured data)

  Global log: $EVENT_LOG
EOF
  exit 1
}

# Parse arguments
MESSAGE=""
SEQUENCE="null"
DRIVE="$DEFAULT_DRIVE"
FORMAT="$DEFAULT_FORMAT"
SHOW_MODE=false

while [[ $# -gt 0 ]]; do
  case $1 in
    --show)
      SHOW_MODE=true
      shift
      ;;
    --message)
      shift
      if [[ $# -ge 1 && "$1" != -* ]]; then
        MESSAGE="$1"
        shift
      else
        echo "Error: --message requires a description string" >&2
        usage
      fi
      ;;
    --seq)
      shift
      if [[ $# -ge 1 && "$1" != -* ]]; then
        SEQUENCE="$1"
        shift
      else
        echo "Error: --seq requires a number" >&2
        usage
      fi
      ;;
    --drive)
      shift
      if [[ $# -ge 1 && "$1" != -* ]]; then
        DRIVE="$1"
        shift
      else
        echo "Error: --drive requires a drive letter" >&2
        usage
      fi
      ;;
    --format)
      shift
      if [[ $# -ge 1 && "$1" != -* ]]; then
        FORMAT="$1"
        shift
      else
        echo "Error: --format requires a format string" >&2
        usage
      fi
      ;;
    -h|--help)
      usage
      ;;
    *)
      echo "Unknown option: $1" >&2
      usage
      ;;
  esac
done

# Handle --show mode
if [[ "$SHOW_MODE" == "true" ]]; then
  show_disks
  exit 0
fi

# Validate required args for read mode
if [[ -z "$MESSAGE" ]]; then
  echo "Error: --message is required for read mode" >&2
  usage
fi

# ---------- main ----------
main() {
  # Generate session hash
  local timestamp=$(date -Iseconds)
  local session_hash=$(generate_session_hash "$timestamp" "$MESSAGE" "$SEQUENCE")

  log "======================================"
  log "Floppy Orchestrator Starting"
  log "======================================"
  log "Session hash: $session_hash"
  log "Message: $MESSAGE"
  log "Sequence: $SEQUENCE"
  log "Timestamp: $timestamp"

  log_event start "{\"session_hash\": \"$session_hash\", \"message\": \"$MESSAGE\", \"sequence\": $SEQUENCE}"

  # Create work directory
  local work_dir="$DISK_ROOT/$session_hash"
  mkdir -p "$work_dir"
  cd "$work_dir"

  log "Work directory: $work_dir"

  # Set up per-disk log file
  LOG_FILE="${session_hash}.log"
  log "Log file: $LOG_FILE"

  # Define file paths
  local img_file="${session_hash}.img"
  local flux_file="${session_hash}.scp"

  # Attempt read
  local read_result=$(stage_read "$session_hash" "$DRIVE" "$FORMAT" "$img_file")

  # Parse result: sectors_found:sectors_total:status
  local sectors_found="${read_result%%:*}"
  local temp="${read_result#*:}"
  local sectors_total="${temp%%:*}"
  local read_status="${temp#*:}"

  local exit_code=0
  local content_hash=""
  local img_path=""
  local scp_files="[]"

  # Always compute content hash if .img exists
  if [[ -f "$img_file" ]]; then
    img_path="$img_file"
    log "Computing content hash..."
    content_hash=$(compute_content_hash "$img_file")
    log "Content hash: $content_hash"
  fi

  # For partial or failed reads, also capture flux
  if [[ "$read_status" == "partial" || "$read_status" == "failed" ]]; then
    log "Capturing flux for partial/failed read..."
    stage_flux_capture "$session_hash" "$DRIVE" "$flux_file"

    # Build SCP file list
    if [[ -f "$flux_file" ]]; then
      scp_files="[\"$flux_file\"]"
    fi
  fi

  # Write metadata
  write_metadata \
    "$session_hash" \
    "$content_hash" \
    "$timestamp" \
    "$MESSAGE" \
    "$SEQUENCE" \
    "$read_status" \
    "$DRIVE" \
    "$FORMAT" \
    "$exit_code" \
    "$img_path" \
    "$scp_files" \
    "$sectors_found" \
    "$sectors_total"

  log "======================================"
  log "COMPLETE: Status = $read_status"
  log "======================================"
  log_event done "{\"session_hash\": \"$session_hash\", \"read_status\": \"$read_status\", \"exit\": $exit_code}"

  return $exit_code
}

# Run main
main
