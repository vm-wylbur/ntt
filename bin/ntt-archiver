#!/usr/bin/env bash
# Author: PB and Claude
# Date: 2025-10-09
# License: (c) HRDAG, 2025, GPL-2 or newer
#
# ------
# ntt/bin/ntt-archiver
#
# Archive disk images to cold storage after copying completes

set -eo pipefail

# Check if running as root
if [[ $EUID -ne 0 ]]; then
   echo "Error: This script must be run with sudo or as root" >&2
   echo "Usage: sudo $0 <medium_hash> [--force] [--verbose]" >&2
   exit 1
fi

# ---------- source config ----------
# Source config from actual user's home (not root's ~)
if [[ -n "$SUDO_USER" ]]; then
  USER_HOME=$(eval echo ~$SUDO_USER)
  CONFIG_FILE="$USER_HOME/.config/ntt/ntt.env"
else
  CONFIG_FILE=~/.config/ntt/ntt.env
fi

if [[ -f "$CONFIG_FILE" ]]; then
  source "$CONFIG_FILE"
else
  # Fallback: use original user when running under sudo
  export PGUSER="${SUDO_USER:-$USER}"
fi

# ---------- config ----------
DB_URL="${NTT_DB_URL:-postgres:///copyjob}"
DB_USER="${PGUSER:-${SUDO_USER:-$USER}}"
IMAGE_ROOT="${NTT_IMAGE_ROOT:-/data/fast/img}"
ARCHIVE_ROOT="${NTT_ARCHIVE_ROOT:-/data/cold/img-read}"
LOG_JSON="${NTT_ARCHIVER_LOG:-/var/log/ntt/archiver.jsonl}"
mkdir -p "$(dirname "$LOG_JSON")"
chmod 755 "$(dirname "$LOG_JSON")" 2>/dev/null || true

# Wrapper for psql that handles running as root
psql_as_user() {
  if [[ $EUID -eq 0 ]] && [[ -n "$DB_USER" ]] && [[ "$DB_USER" != "root" ]]; then
    sudo -u "$DB_USER" psql "$@"
  else
    psql "$@"
  fi
}

# ---------- logging functions ----------
log() {
  jq -cn --arg ts "$(date -Iseconds)" \
        --arg stage "$1" \
        --argjson extra "$2" \
        '$extra + {ts: $ts, stage: $stage}' \
  >> "$LOG_JSON"
  chmod 644 "$LOG_JSON" 2>/dev/null || true
}

fail() {
  echo "Error: $1" >&2
  log error "{\"msg\": \"$1\"}"
  exit 1
}

# ---------- argparse ----------
usage() {
  cat <<EOF
Usage:
  sudo $0 <medium_hash> [--force] [--verbose]

Archives disk image files to cold storage after copying completes.

Arguments:
  medium_hash    The medium hash to archive

Options:
  --force        Skip safety checks (copy completion, existing archive)
  --verbose      Show tar progress and detailed output

Archives:
  Source: $IMAGE_ROOT/<hash>*
  Destination: $ARCHIVE_ROOT/<hash>.tar.zst

Safety checks (unless --force):
  - All inodes must be copied
  - Archive must not already exist

Exit codes:
  0 = success
  1 = error
  2 = already archived (skipped)

Examples:
  sudo $0 af1349b9f5f9a1a6a0404dea36dcc949
  sudo $0 af1349b9f5f9a1a6a0404dea36dcc949 --force
EOF
  exit 1
}

# Parse arguments
[[ $# -ge 1 ]] || usage

MEDIUM_HASH=""
FORCE=false
VERBOSE=false

while [[ $# -gt 0 ]]; do
  case $1 in
    --force)
      FORCE=true
      shift
      ;;
    --verbose)
      VERBOSE=true
      shift
      ;;
    -*)
      echo "Unknown option: $1" >&2
      usage
      ;;
    *)
      if [[ -z "$MEDIUM_HASH" ]]; then
        MEDIUM_HASH="$1"
        shift
      else
        echo "Error: Multiple medium hashes not supported" >&2
        usage
      fi
      ;;
  esac
done

[[ -n "$MEDIUM_HASH" ]] || usage

# Validate hash format (16-64 hex chars)
if [[ ! "$MEDIUM_HASH" =~ ^[a-f0-9]{16,64}$ ]]; then
  fail "Invalid medium_hash format (must be 16-64 hex chars)"
fi

# ---------- main ----------
echo "[$(date -Iseconds)] Starting archive process for $MEDIUM_HASH" >&2
log archive_start "{\"medium_hash\": \"$MEDIUM_HASH\", \"force\": $FORCE, \"verbose\": $VERBOSE}"

# Check if source files exist
SOURCE_FILES=("$IMAGE_ROOT/${MEDIUM_HASH}"*)
if [[ ! -e "${SOURCE_FILES[0]}" ]]; then
  fail "No source files found: $IMAGE_ROOT/${MEDIUM_HASH}*"
fi

if [[ "$VERBOSE" == "true" ]]; then
  echo "[$(date -Iseconds)] Found source files:" >&2
  for f in "${SOURCE_FILES[@]}"; do
    ls -lh "$f" >&2
  done
fi

# Check if archive already exists
ARCHIVE_FILE="$ARCHIVE_ROOT/${MEDIUM_HASH}.tar.zst"
if [[ -f "$ARCHIVE_FILE" ]]; then
  if [[ "$FORCE" == "true" ]]; then
    echo "[$(date -Iseconds)] WARNING: Archive already exists, overwriting (--force)" >&2
    log archive_overwrite "{\"medium_hash\": \"$MEDIUM_HASH\", \"archive\": \"$ARCHIVE_FILE\"}"
  else
    echo "[$(date -Iseconds)] Archive already exists: $ARCHIVE_FILE" >&2
    log archive_exists "{\"medium_hash\": \"$MEDIUM_HASH\", \"archive\": \"$ARCHIVE_FILE\"}"
    exit 2
  fi
fi

# Safety check: Verify all inodes are copied (unless --force)
if [[ "$FORCE" == "false" ]]; then
  echo "[$(date -Iseconds)] Checking copy completion..." >&2

  COPY_STATUS=$(psql_as_user "$DB_URL" -tAc "
    SELECT
      COUNT(*) FILTER (WHERE copied = true) as copied,
      COUNT(*) FILTER (WHERE copied = false) as pending,
      COUNT(*) as total
    FROM inode
    WHERE medium_hash = '$MEDIUM_HASH'
  " 2>/dev/null)

  COPIED=$(echo "$COPY_STATUS" | cut -d'|' -f1)
  PENDING=$(echo "$COPY_STATUS" | cut -d'|' -f2)
  TOTAL=$(echo "$COPY_STATUS" | cut -d'|' -f3)

  if [[ $TOTAL -eq 0 ]]; then
    echo "[$(date -Iseconds)] WARNING: No inodes found for this medium (empty filesystem?)" >&2
    log archive_no_inodes "{\"medium_hash\": \"$MEDIUM_HASH\"}"
  elif [[ $PENDING -gt 0 ]]; then
    fail "Copy incomplete: $PENDING of $TOTAL inodes not copied (use --force to skip)"
  else
    echo "[$(date -Iseconds)] Copy complete: $COPIED of $TOTAL inodes copied" >&2
    log copy_verified "{\"medium_hash\": \"$MEDIUM_HASH\", \"copied\": $COPIED, \"total\": $TOTAL}"
  fi
fi

# Create archive
echo "[$(date -Iseconds)] Creating archive: $ARCHIVE_FILE" >&2
log archive_create_start "{\"medium_hash\": \"$MEDIUM_HASH\", \"archive\": \"$ARCHIVE_FILE\"}"

TAR_OPTS="-C $IMAGE_ROOT -c"
if [[ "$VERBOSE" == "true" ]]; then
  TAR_OPTS="$TAR_OPTS -v"
fi

# Build file list (just basenames, tar will handle them from -C directory)
FILE_PATTERNS=()
for f in "${SOURCE_FILES[@]}"; do
  FILE_PATTERNS+=("$(basename "$f")")
done

# Create archive with zstd compression
if tar $TAR_OPTS "${FILE_PATTERNS[@]}" | zstd > "$ARCHIVE_FILE"; then
  echo "[$(date -Iseconds)] Archive created successfully" >&2
else
  fail "Archive creation failed (tar exit code: ${PIPESTATUS[0]}, zstd exit code: ${PIPESTATUS[1]})"
fi

# Chown archive to pball:pball with 644
if [[ -n "$SUDO_USER" ]]; then
  chown "$SUDO_USER:$SUDO_USER" "$ARCHIVE_FILE"
  chmod 644 "$ARCHIVE_FILE"
  echo "[$(date -Iseconds)] Archive ownership: $SUDO_USER:$SUDO_USER 644" >&2
fi

# Verify archive exists and has size > 0
if [[ ! -f "$ARCHIVE_FILE" ]]; then
  fail "Archive verification failed: file not found after creation"
fi

ARCHIVE_SIZE=$(stat -c%s "$ARCHIVE_FILE")
if [[ $ARCHIVE_SIZE -eq 0 ]]; then
  fail "Archive verification failed: file size is 0"
fi

ARCHIVE_SIZE_HUMAN=$(stat -c%s "$ARCHIVE_FILE" | numfmt --to=iec-i --suffix=B 2>/dev/null || echo "${ARCHIVE_SIZE} bytes")
echo "[$(date -Iseconds)] Archive verified: $ARCHIVE_SIZE_HUMAN" >&2
log archive_verified "{\"medium_hash\": \"$MEDIUM_HASH\", \"archive\": \"$ARCHIVE_FILE\", \"size\": $ARCHIVE_SIZE}"

# Remove source files
echo "[$(date -Iseconds)] Removing source files..." >&2
log source_remove_start "{\"medium_hash\": \"$MEDIUM_HASH\", \"count\": ${#SOURCE_FILES[@]}}"

for f in "${SOURCE_FILES[@]}"; do
  if [[ "$VERBOSE" == "true" ]]; then
    echo "[$(date -Iseconds)]   Removing: $f" >&2
  fi
  rm -f "$f"
done

# Verify source files are gone
REMAINING_FILES=("$IMAGE_ROOT/${MEDIUM_HASH}"*)
if [[ -e "${REMAINING_FILES[0]}" ]]; then
  echo "[$(date -Iseconds)] WARNING: Some source files still exist:" >&2
  for f in "${REMAINING_FILES[@]}"; do
    ls -lh "$f" >&2
  done
  fail "Source file removal verification failed"
fi

echo "[$(date -Iseconds)] Source files removed successfully" >&2
log source_removed "{\"medium_hash\": \"$MEDIUM_HASH\"}"

# Success
echo "[$(date -Iseconds)] Archive complete: $ARCHIVE_FILE ($ARCHIVE_SIZE_HUMAN)" >&2
log archive_done "{\"medium_hash\": \"$MEDIUM_HASH\", \"archive\": \"$ARCHIVE_FILE\", \"size\": $ARCHIVE_SIZE, \"exit\": 0}"

exit 0
