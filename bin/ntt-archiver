#!/usr/bin/env bash
# Author: PB and Claude
# Date: 2025-10-09
# License: (c) HRDAG, 2025, GPL-2 or newer
#
# ------
# ntt/bin/ntt-archiver
#
# Archive disk images to cold storage after copying completes
#
# bash-logger: INTEGRATED (2025-11-02)

set -eo pipefail

# Check if running as root
if [[ $EUID -ne 0 ]]; then
   echo "Error: This script must be run with sudo or as root" >&2
   echo "Usage: sudo $0 <medium_hash> [--force] [--verbose]" >&2
   exit 1
fi

# ---------- source config ----------
# Source config from actual user's home (not root's ~)
if [[ -n "$SUDO_USER" ]]; then
  USER_HOME=$(eval echo ~$SUDO_USER)
  CONFIG_FILE="$USER_HOME/.config/ntt/ntt.env"
else
  CONFIG_FILE=~/.config/ntt/ntt.env
fi

if [[ -f "$CONFIG_FILE" ]]; then
  source "$CONFIG_FILE"
else
  # Fallback: use original user when running under sudo
  export PGUSER="${SUDO_USER:-$USER}"
fi

# ---------- config ----------
DB_URL="${NTT_DB_URL:-postgres:///copyjob}"
DB_USER="${PGUSER:-${SUDO_USER:-$USER}}"
IMAGE_ROOT="${NTT_IMAGE_ROOT:-/data/fast/img}"
ARCHIVE_ROOT="${NTT_IMAGES_ROOT:-/data/cold/img-read}"
LOG_FILE="${NTT_ARCHIVER_LOG:-/var/log/ntt/archiver.jsonl}"
mkdir -p "$(dirname "$LOG_FILE")"
chmod 755 "$(dirname "$LOG_FILE")" 2>/dev/null || true

# Source bash-logger
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$(cd "$SCRIPT_DIR/../lib" && pwd)"
source "$LIB_DIR/bash-logger.sh"

# Initialize logging (must be after LOG_FILE is set)
log_init || exit 1

# Wrapper for psql that handles running as root
psql_as_user() {
  if [[ $EUID -eq 0 ]] && [[ -n "$DB_USER" ]] && [[ "$DB_USER" != "root" ]]; then
    sudo -u "$DB_USER" psql "$@"
  else
    psql "$@"
  fi
}

# ---------- logging functions ----------
# NOTE: log_info/log_warn/log_error provided by bash-logger.sh

fail() {
  log_error "Error: $1"
  exit 1
}

# ---------- argparse ----------
usage() {
  cat <<EOF
Usage:
  sudo $0 <medium_hash> [--force] [--verbose] [--floppy]

Archives disk image files to cold storage after copying completes.

Arguments:
  medium_hash    The medium hash to archive

Options:
  --force        Skip safety checks (copy completion, existing archive)
  --verbose      Show tar progress and detailed output
  --floppy       Archive floppy disk (different source/destination)

Archives:
  Normal mode:
    Source: $IMAGE_ROOT/<hash>*
    Destination: $ARCHIVE_ROOT/<hash>.tar.zst

  Floppy mode (--floppy):
    Source: /data/fast/floppies/disks/<hash>/ (entire directory)
    Destination: $ARCHIVE_ROOT/floppies/<hash>.tar.zst

Safety checks (unless --force):
  - All inodes must be copied (normal mode only)
  - Archive must not already exist

Exit codes:
  0 = success
  1 = error
  2 = already archived (skipped)

Examples:
  sudo $0 af1349b9f5f9a1a6a0404dea36dcc949
  sudo $0 af1349b9f5f9a1a6a0404dea36dcc949 --force
  sudo $0 af1349b9f5f9a1a6a0404dea36dcc949 --floppy
EOF
  exit 1
}

# Parse arguments
[[ $# -ge 1 ]] || usage

MEDIUM_HASH=""
FORCE=false
VERBOSE=false
FLOPPY_MODE=false

while [[ $# -gt 0 ]]; do
  case $1 in
    --force)
      FORCE=true
      shift
      ;;
    --verbose)
      VERBOSE=true
      shift
      ;;
    --floppy)
      FLOPPY_MODE=true
      shift
      ;;
    -*)
      echo "Unknown option: $1" >&2
      usage
      ;;
    *)
      if [[ -z "$MEDIUM_HASH" ]]; then
        MEDIUM_HASH="$1"
        shift
      else
        echo "Error: Multiple medium hashes not supported" >&2
        usage
      fi
      ;;
  esac
done

[[ -n "$MEDIUM_HASH" ]] || usage

# Validate hash format (16-64 hex chars)
if [[ ! "$MEDIUM_HASH" =~ ^[a-f0-9]{16,64}$ ]]; then
  fail "Invalid medium_hash format (must be 16-64 hex chars)"
fi

# ---------- main ----------
log_info "Starting archive process for $MEDIUM_HASH (force=$FORCE verbose=$VERBOSE floppy=$FLOPPY_MODE)"

# Check if source files exist
if [[ "$FLOPPY_MODE" == "true" ]]; then
  # Floppy mode: archive entire directory
  FLOPPY_SOURCE_DIR="/data/fast/floppies/disks/${MEDIUM_HASH}"

  if [[ ! -d "$FLOPPY_SOURCE_DIR" ]]; then
    fail "Floppy source directory not found: $FLOPPY_SOURCE_DIR"
  fi

  # Get all files in directory
  SOURCE_FILES=("$FLOPPY_SOURCE_DIR"/*)
  if [[ ! -e "${SOURCE_FILES[0]}" ]]; then
    fail "No files found in floppy directory: $FLOPPY_SOURCE_DIR"
  fi

  FOUND_IN="$(dirname "$FLOPPY_SOURCE_DIR")"
  log_info "Found floppy directory: $FLOPPY_SOURCE_DIR"

  if [[ "$VERBOSE" == "true" ]]; then
    log_info "Found files:"
    for f in "${SOURCE_FILES[@]}"; do
      ls -lh "$f" >&2
    done
  fi
else
  # Normal mode: search for files with hash prefix
  SEARCH_PATHS=("$IMAGE_ROOT" "/data/cold/img-unprocessed")
  SOURCE_FILES=()
  FOUND_IN=""

  for search_path in "${SEARCH_PATHS[@]}"; do
    CANDIDATES=("$search_path/${MEDIUM_HASH}"*)
    if [[ -e "${CANDIDATES[0]}" ]]; then
      SOURCE_FILES=("${CANDIDATES[@]}")
      FOUND_IN="$search_path"
      break
    fi
  done

  if [[ ${#SOURCE_FILES[@]} -eq 0 ]]; then
    fail "No source files found in: ${SEARCH_PATHS[*]} (pattern: ${MEDIUM_HASH}*)"
  fi

  log_info "Found source files in: $FOUND_IN"

  if [[ "$VERBOSE" == "true" ]]; then
    log_info "Found source files:"
    for f in "${SOURCE_FILES[@]}"; do
      ls -lh "$f" >&2
    done
  fi
fi

# Check if archive already exists
if [[ "$FLOPPY_MODE" == "true" ]]; then
  ARCHIVE_FILE="$ARCHIVE_ROOT/floppies/${MEDIUM_HASH}.tar.zst"
  mkdir -p "$ARCHIVE_ROOT/floppies"
else
  ARCHIVE_FILE="$ARCHIVE_ROOT/${MEDIUM_HASH}.tar.zst"
fi
if [[ -f "$ARCHIVE_FILE" ]]; then
  if [[ "$FORCE" == "true" ]]; then
    log_warn "Archive already exists, overwriting (--force): $ARCHIVE_FILE"
  else
    log_info "Archive already exists (skipping): $ARCHIVE_FILE"
    exit 2
  fi
fi

# Safety check: Verify all inodes are copied (unless --force or floppy mode)
if [[ "$FORCE" == "false" ]] && [[ "$FLOPPY_MODE" == "false" ]]; then
  log_info "Checking copy completion..."

  COPY_STATUS=$(psql_as_user "$DB_URL" -tAc "
    SELECT
      COUNT(*) FILTER (WHERE copied = true) as copied,
      COUNT(*) FILTER (WHERE copied = false) as pending,
      COUNT(*) as total
    FROM inode
    WHERE medium_hash = '$MEDIUM_HASH'
  " 2>/dev/null | grep -v "^Pager" | grep "|")

  COPIED=$(echo "$COPY_STATUS" | cut -d'|' -f1)
  PENDING=$(echo "$COPY_STATUS" | cut -d'|' -f2)
  TOTAL=$(echo "$COPY_STATUS" | cut -d'|' -f3)

  if [[ $TOTAL -eq 0 ]]; then
    log_warn "No inodes found for this medium (empty filesystem?)"
  elif [[ $PENDING -gt 0 ]]; then
    fail "Copy incomplete: $PENDING of $TOTAL inodes not copied (use --force to skip)"
  else
    log_info "Copy complete: $COPIED of $TOTAL inodes copied"
  fi
elif [[ "$FLOPPY_MODE" == "true" ]]; then
  log_info "Floppy mode: skipping inode copy verification"
fi

# Create archive
log_info "Creating archive: $ARCHIVE_FILE"

if [[ "$FLOPPY_MODE" == "true" ]]; then
  # Floppy mode: archive entire directory
  TAR_OPTS="-C $FOUND_IN -c"
  if [[ "$VERBOSE" == "true" ]]; then
    TAR_OPTS="$TAR_OPTS -v"
  fi
  FILE_PATTERNS=("$MEDIUM_HASH")
else
  # Normal mode: archive individual files
  TAR_OPTS="-C $FOUND_IN -c"
  if [[ "$VERBOSE" == "true" ]]; then
    TAR_OPTS="$TAR_OPTS -v"
  fi

  # Build file list (just basenames, tar will handle them from -C directory)
  FILE_PATTERNS=()
  for f in "${SOURCE_FILES[@]}"; do
    FILE_PATTERNS+=("$(basename "$f")")
  done
fi

# Create archive with zstd compression
if tar $TAR_OPTS "${FILE_PATTERNS[@]}" | zstd > "$ARCHIVE_FILE"; then
  log_info "Archive created successfully"
else
  fail "Archive creation failed (tar exit code: ${PIPESTATUS[0]}, zstd exit code: ${PIPESTATUS[1]})"
fi

# Chown archive to pball:pball with 644
if [[ -n "$SUDO_USER" ]]; then
  chown "$SUDO_USER:$SUDO_USER" "$ARCHIVE_FILE"
  chmod 644 "$ARCHIVE_FILE"
  log_info "Archive ownership: $SUDO_USER:$SUDO_USER 644"
fi

# Verify archive exists and has size > 0
if [[ ! -f "$ARCHIVE_FILE" ]]; then
  fail "Archive verification failed: file not found after creation"
fi

ARCHIVE_SIZE=$(stat -c%s "$ARCHIVE_FILE")
if [[ $ARCHIVE_SIZE -eq 0 ]]; then
  fail "Archive verification failed: file size is 0"
fi

ARCHIVE_SIZE_HUMAN=$(stat -c%s "$ARCHIVE_FILE" | numfmt --to=iec-i --suffix=B 2>/dev/null || echo "${ARCHIVE_SIZE} bytes")
log_info "Archive verified: $ARCHIVE_SIZE_HUMAN"

# Remove source files
if [[ "$FLOPPY_MODE" == "true" ]]; then
  # Floppy mode: remove entire directory
  log_info "Removing floppy directory: $FLOPPY_SOURCE_DIR"

  rm -rf "$FLOPPY_SOURCE_DIR"

  # Verify directory is gone
  if [[ -d "$FLOPPY_SOURCE_DIR" ]]; then
    fail "Floppy directory removal failed: $FLOPPY_SOURCE_DIR still exists"
  fi

  log_info "Floppy directory removed successfully"
else
  # Normal mode: remove individual files
  log_info "Removing source files (${#SOURCE_FILES[@]} files)..."

  for f in "${SOURCE_FILES[@]}"; do
    if [[ "$VERBOSE" == "true" ]]; then
      log_info "  Removing: $f"
    fi
    rm -f "$f"
  done

  # Verify source files are gone
  REMAINING_FILES=("$FOUND_IN/${MEDIUM_HASH}"*)
  if [[ -e "${REMAINING_FILES[0]}" ]]; then
    log_warn "Some source files still exist:"
    for f in "${REMAINING_FILES[@]}"; do
      ls -lh "$f" >&2
    done
    fail "Source file removal verification failed"
  fi

  log_info "Source files removed successfully"
fi

# Success
log_info "Archive complete: $ARCHIVE_FILE ($ARCHIVE_SIZE_HUMAN)"

exit 0
