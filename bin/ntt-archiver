#!/usr/bin/env bash
# Author: PB and Claude
# Date: 2025-10-09
# License: (c) HRDAG, 2025, GPL-2 or newer
#
# ------
# ntt/bin/ntt-archiver
#
# Archive disk images to cold storage after copying completes

set -eo pipefail

# Check if running as root
if [[ $EUID -ne 0 ]]; then
   echo "Error: This script must be run with sudo or as root" >&2
   echo "Usage: sudo $0 <medium_hash> [--force] [--verbose]" >&2
   exit 1
fi

# ---------- source config ----------
# Source config from actual user's home (not root's ~)
if [[ -n "$SUDO_USER" ]]; then
  USER_HOME=$(eval echo ~$SUDO_USER)
  CONFIG_FILE="$USER_HOME/.config/ntt/ntt.env"
else
  CONFIG_FILE=~/.config/ntt/ntt.env
fi

if [[ -f "$CONFIG_FILE" ]]; then
  source "$CONFIG_FILE"
else
  # Fallback: use original user when running under sudo
  export PGUSER="${SUDO_USER:-$USER}"
fi

# ---------- config ----------
DB_URL="${NTT_DB_URL:-postgres:///copyjob}"
DB_USER="${PGUSER:-${SUDO_USER:-$USER}}"
IMAGE_ROOT="${NTT_IMAGE_ROOT:-/data/fast/img}"
ARCHIVE_ROOT="${NTT_IMAGES_ROOT:-/data/cold/img-read}"
LOG_JSON="${NTT_ARCHIVER_LOG:-/var/log/ntt/archiver.jsonl}"
mkdir -p "$(dirname "$LOG_JSON")"
chmod 755 "$(dirname "$LOG_JSON")" 2>/dev/null || true

# Wrapper for psql that handles running as root
psql_as_user() {
  if [[ $EUID -eq 0 ]] && [[ -n "$DB_USER" ]] && [[ "$DB_USER" != "root" ]]; then
    sudo -u "$DB_USER" psql "$@"
  else
    psql "$@"
  fi
}

# ---------- logging functions ----------
log() {
  jq -cn --arg ts "$(date -Iseconds)" \
        --arg stage "$1" \
        --argjson extra "$2" \
        '$extra + {ts: $ts, stage: $stage}' \
  >> "$LOG_JSON"
  chmod 644 "$LOG_JSON" 2>/dev/null || true
}

fail() {
  echo "Error: $1" >&2
  log error "{\"msg\": \"$1\"}"
  exit 1
}

# ---------- argparse ----------
usage() {
  cat <<EOF
Usage:
  sudo $0 <medium_hash> [--force] [--verbose] [--floppy]

Archives disk image files to cold storage after copying completes.

Arguments:
  medium_hash    The medium hash to archive

Options:
  --force        Skip safety checks (copy completion, existing archive)
  --verbose      Show tar progress and detailed output
  --floppy       Archive floppy disk (different source/destination)

Archives:
  Normal mode:
    Source: $IMAGE_ROOT/<hash>*
    Destination: $ARCHIVE_ROOT/<hash>.tar.zst

  Floppy mode (--floppy):
    Source: /data/fast/floppies/disks/<hash>/ (entire directory)
    Destination: $ARCHIVE_ROOT/floppies/<hash>.tar.zst

Safety checks (unless --force):
  - All inodes must be copied (normal mode only)
  - Archive must not already exist

Exit codes:
  0 = success
  1 = error
  2 = already archived (skipped)

Examples:
  sudo $0 af1349b9f5f9a1a6a0404dea36dcc949
  sudo $0 af1349b9f5f9a1a6a0404dea36dcc949 --force
  sudo $0 af1349b9f5f9a1a6a0404dea36dcc949 --floppy
EOF
  exit 1
}

# Parse arguments
[[ $# -ge 1 ]] || usage

MEDIUM_HASH=""
FORCE=false
VERBOSE=false
FLOPPY_MODE=false

while [[ $# -gt 0 ]]; do
  case $1 in
    --force)
      FORCE=true
      shift
      ;;
    --verbose)
      VERBOSE=true
      shift
      ;;
    --floppy)
      FLOPPY_MODE=true
      shift
      ;;
    -*)
      echo "Unknown option: $1" >&2
      usage
      ;;
    *)
      if [[ -z "$MEDIUM_HASH" ]]; then
        MEDIUM_HASH="$1"
        shift
      else
        echo "Error: Multiple medium hashes not supported" >&2
        usage
      fi
      ;;
  esac
done

[[ -n "$MEDIUM_HASH" ]] || usage

# Validate hash format (16-64 hex chars)
if [[ ! "$MEDIUM_HASH" =~ ^[a-f0-9]{16,64}$ ]]; then
  fail "Invalid medium_hash format (must be 16-64 hex chars)"
fi

# ---------- main ----------
echo "[$(date -Iseconds)] Starting archive process for $MEDIUM_HASH" >&2
log archive_start "{\"medium_hash\": \"$MEDIUM_HASH\", \"force\": $FORCE, \"verbose\": $VERBOSE, \"floppy\": $FLOPPY_MODE}"

# Check if source files exist
if [[ "$FLOPPY_MODE" == "true" ]]; then
  # Floppy mode: archive entire directory
  FLOPPY_SOURCE_DIR="/data/fast/floppies/disks/${MEDIUM_HASH}"

  if [[ ! -d "$FLOPPY_SOURCE_DIR" ]]; then
    fail "Floppy source directory not found: $FLOPPY_SOURCE_DIR"
  fi

  # Get all files in directory
  SOURCE_FILES=("$FLOPPY_SOURCE_DIR"/*)
  if [[ ! -e "${SOURCE_FILES[0]}" ]]; then
    fail "No files found in floppy directory: $FLOPPY_SOURCE_DIR"
  fi

  FOUND_IN="$(dirname "$FLOPPY_SOURCE_DIR")"
  echo "[$(date -Iseconds)] Found floppy directory: $FLOPPY_SOURCE_DIR" >&2

  if [[ "$VERBOSE" == "true" ]]; then
    echo "[$(date -Iseconds)] Found files:" >&2
    for f in "${SOURCE_FILES[@]}"; do
      ls -lh "$f" >&2
    done
  fi
else
  # Normal mode: search for files with hash prefix
  SEARCH_PATHS=("$IMAGE_ROOT" "/data/cold/img-unprocessed")
  SOURCE_FILES=()
  FOUND_IN=""

  for search_path in "${SEARCH_PATHS[@]}"; do
    CANDIDATES=("$search_path/${MEDIUM_HASH}"*)
    if [[ -e "${CANDIDATES[0]}" ]]; then
      SOURCE_FILES=("${CANDIDATES[@]}")
      FOUND_IN="$search_path"
      break
    fi
  done

  if [[ ${#SOURCE_FILES[@]} -eq 0 ]]; then
    fail "No source files found in: ${SEARCH_PATHS[*]} (pattern: ${MEDIUM_HASH}*)"
  fi

  echo "[$(date -Iseconds)] Found source files in: $FOUND_IN" >&2

  if [[ "$VERBOSE" == "true" ]]; then
    echo "[$(date -Iseconds)] Found source files:" >&2
    for f in "${SOURCE_FILES[@]}"; do
      ls -lh "$f" >&2
    done
  fi
fi

# Check if archive already exists
if [[ "$FLOPPY_MODE" == "true" ]]; then
  ARCHIVE_FILE="$ARCHIVE_ROOT/floppies/${MEDIUM_HASH}.tar.zst"
  mkdir -p "$ARCHIVE_ROOT/floppies"
else
  ARCHIVE_FILE="$ARCHIVE_ROOT/${MEDIUM_HASH}.tar.zst"
fi
if [[ -f "$ARCHIVE_FILE" ]]; then
  if [[ "$FORCE" == "true" ]]; then
    echo "[$(date -Iseconds)] WARNING: Archive already exists, overwriting (--force)" >&2
    log archive_overwrite "{\"medium_hash\": \"$MEDIUM_HASH\", \"archive\": \"$ARCHIVE_FILE\"}"
  else
    echo "[$(date -Iseconds)] Archive already exists: $ARCHIVE_FILE" >&2
    log archive_exists "{\"medium_hash\": \"$MEDIUM_HASH\", \"archive\": \"$ARCHIVE_FILE\"}"
    exit 2
  fi
fi

# Safety check: Verify all inodes are copied (unless --force or floppy mode)
if [[ "$FORCE" == "false" ]] && [[ "$FLOPPY_MODE" == "false" ]]; then
  echo "[$(date -Iseconds)] Checking copy completion..." >&2

  COPY_STATUS=$(psql_as_user "$DB_URL" -tAc "
    SELECT
      COUNT(*) FILTER (WHERE copied = true) as copied,
      COUNT(*) FILTER (WHERE copied = false) as pending,
      COUNT(*) as total
    FROM inode
    WHERE medium_hash = '$MEDIUM_HASH'
  " 2>/dev/null | grep -v "^Pager" | grep "|")

  COPIED=$(echo "$COPY_STATUS" | cut -d'|' -f1)
  PENDING=$(echo "$COPY_STATUS" | cut -d'|' -f2)
  TOTAL=$(echo "$COPY_STATUS" | cut -d'|' -f3)

  if [[ $TOTAL -eq 0 ]]; then
    echo "[$(date -Iseconds)] WARNING: No inodes found for this medium (empty filesystem?)" >&2
    log archive_no_inodes "{\"medium_hash\": \"$MEDIUM_HASH\"}"
  elif [[ $PENDING -gt 0 ]]; then
    fail "Copy incomplete: $PENDING of $TOTAL inodes not copied (use --force to skip)"
  else
    echo "[$(date -Iseconds)] Copy complete: $COPIED of $TOTAL inodes copied" >&2
    log copy_verified "{\"medium_hash\": \"$MEDIUM_HASH\", \"copied\": $COPIED, \"total\": $TOTAL, \"floppy\": false}"
  fi
elif [[ "$FLOPPY_MODE" == "true" ]]; then
  echo "[$(date -Iseconds)] Floppy mode: skipping inode copy verification" >&2
fi

# Create archive
echo "[$(date -Iseconds)] Creating archive: $ARCHIVE_FILE" >&2
log archive_create_start "{\"medium_hash\": \"$MEDIUM_HASH\", \"archive\": \"$ARCHIVE_FILE\", \"floppy\": $FLOPPY_MODE}"

if [[ "$FLOPPY_MODE" == "true" ]]; then
  # Floppy mode: archive entire directory
  TAR_OPTS="-C $FOUND_IN -c"
  if [[ "$VERBOSE" == "true" ]]; then
    TAR_OPTS="$TAR_OPTS -v"
  fi
  FILE_PATTERNS=("$MEDIUM_HASH")
else
  # Normal mode: archive individual files
  TAR_OPTS="-C $FOUND_IN -c"
  if [[ "$VERBOSE" == "true" ]]; then
    TAR_OPTS="$TAR_OPTS -v"
  fi

  # Build file list (just basenames, tar will handle them from -C directory)
  FILE_PATTERNS=()
  for f in "${SOURCE_FILES[@]}"; do
    FILE_PATTERNS+=("$(basename "$f")")
  done
fi

# Create archive with zstd compression
if tar $TAR_OPTS "${FILE_PATTERNS[@]}" | zstd > "$ARCHIVE_FILE"; then
  echo "[$(date -Iseconds)] Archive created successfully" >&2
else
  fail "Archive creation failed (tar exit code: ${PIPESTATUS[0]}, zstd exit code: ${PIPESTATUS[1]})"
fi

# Chown archive to pball:pball with 644
if [[ -n "$SUDO_USER" ]]; then
  chown "$SUDO_USER:$SUDO_USER" "$ARCHIVE_FILE"
  chmod 644 "$ARCHIVE_FILE"
  echo "[$(date -Iseconds)] Archive ownership: $SUDO_USER:$SUDO_USER 644" >&2
fi

# Verify archive exists and has size > 0
if [[ ! -f "$ARCHIVE_FILE" ]]; then
  fail "Archive verification failed: file not found after creation"
fi

ARCHIVE_SIZE=$(stat -c%s "$ARCHIVE_FILE")
if [[ $ARCHIVE_SIZE -eq 0 ]]; then
  fail "Archive verification failed: file size is 0"
fi

ARCHIVE_SIZE_HUMAN=$(stat -c%s "$ARCHIVE_FILE" | numfmt --to=iec-i --suffix=B 2>/dev/null || echo "${ARCHIVE_SIZE} bytes")
echo "[$(date -Iseconds)] Archive verified: $ARCHIVE_SIZE_HUMAN" >&2
log archive_verified "{\"medium_hash\": \"$MEDIUM_HASH\", \"archive\": \"$ARCHIVE_FILE\", \"size\": $ARCHIVE_SIZE, \"floppy\": $FLOPPY_MODE}"

# Remove source files
if [[ "$FLOPPY_MODE" == "true" ]]; then
  # Floppy mode: remove entire directory
  echo "[$(date -Iseconds)] Removing floppy directory: $FLOPPY_SOURCE_DIR" >&2
  log source_remove_start "{\"medium_hash\": \"$MEDIUM_HASH\", \"floppy\": true, \"directory\": \"$FLOPPY_SOURCE_DIR\"}"

  rm -rf "$FLOPPY_SOURCE_DIR"

  # Verify directory is gone
  if [[ -d "$FLOPPY_SOURCE_DIR" ]]; then
    fail "Floppy directory removal failed: $FLOPPY_SOURCE_DIR still exists"
  fi

  echo "[$(date -Iseconds)] Floppy directory removed successfully" >&2
  log source_removed "{\"medium_hash\": \"$MEDIUM_HASH\", \"floppy\": true}"
else
  # Normal mode: remove individual files
  echo "[$(date -Iseconds)] Removing source files..." >&2
  log source_remove_start "{\"medium_hash\": \"$MEDIUM_HASH\", \"count\": ${#SOURCE_FILES[@]}, \"floppy\": false}"

  for f in "${SOURCE_FILES[@]}"; do
    if [[ "$VERBOSE" == "true" ]]; then
      echo "[$(date -Iseconds)]   Removing: $f" >&2
    fi
    rm -f "$f"
  done

  # Verify source files are gone
  REMAINING_FILES=("$FOUND_IN/${MEDIUM_HASH}"*)
  if [[ -e "${REMAINING_FILES[0]}" ]]; then
    echo "[$(date -Iseconds)] WARNING: Some source files still exist:" >&2
    for f in "${REMAINING_FILES[@]}"; do
      ls -lh "$f" >&2
    done
    fail "Source file removal verification failed"
  fi

  echo "[$(date -Iseconds)] Source files removed successfully" >&2
  log source_removed "{\"medium_hash\": \"$MEDIUM_HASH\", \"floppy\": false}"
fi

# Success
echo "[$(date -Iseconds)] Archive complete: $ARCHIVE_FILE ($ARCHIVE_SIZE_HUMAN)" >&2
log archive_done "{\"medium_hash\": \"$MEDIUM_HASH\", \"archive\": \"$ARCHIVE_FILE\", \"size\": $ARCHIVE_SIZE, \"floppy\": $FLOPPY_MODE, \"exit\": 0}"

exit 0
